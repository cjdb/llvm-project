// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_TUPLE
#define _LIBCPP_TUPLE

// clang-format off

/*
    tuple synopsis

namespace std
{

template <class... T>
class tuple {
public:
    explicit(see-below) constexpr tuple();
    explicit(see-below) tuple(const T&...);  // constexpr in C++14
    template <class... U>
        explicit(see-below) tuple(U&&...);  // constexpr in C++14
    tuple(const tuple&) = default;
    tuple(tuple&&) = default;

    template<class... UTypes>
        constexpr explicit(see-below) tuple(tuple<UTypes...>&);  // C++23
    template <class... U>
        explicit(see-below) tuple(const tuple<U...>&);  // constexpr in C++14
    template <class... U>
        explicit(see-below) tuple(tuple<U...>&&);  // constexpr in C++14
    template<class... UTypes>
        constexpr explicit(see-below) tuple(const tuple<UTypes...>&&); // C++23

    template<class U1, class U2>
        constexpr explicit(see-below) tuple(pair<U1, U2>&);  // iff sizeof...(Types) == 2 // C++23
    template <class U1, class U2>
        explicit(see-below) tuple(const pair<U1, U2>&); // iff sizeof...(T) == 2 // constexpr in C++14
    template <class U1, class U2>
        explicit(see-below) tuple(pair<U1, U2>&&); // iff sizeof...(T) == 2  // constexpr in C++14
    template<class U1, class U2>
        constexpr explicit(see-below) tuple(const pair<U1, U2>&&);  // iff sizeof...(Types) == 2 // C++23

    // allocator-extended constructors
    template <class Alloc>
        tuple(allocator_arg_t, const Alloc& a);
    template <class Alloc>
        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, const T&...);          // constexpr in C++20
    template <class Alloc, class... U>
        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, U&&...);               // constexpr in C++20
    template <class Alloc>
        tuple(allocator_arg_t, const Alloc& a, const tuple&);                             // constexpr in C++20
    template <class Alloc>
        tuple(allocator_arg_t, const Alloc& a, tuple&&);                                  // constexpr in C++20
    template<class Alloc, class... UTypes>
        constexpr explicit(see-below)
          tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&);                      // C++23
    template <class Alloc, class... U>
        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, const tuple<U...>&);   // constexpr in C++20
    template <class Alloc, class... U>
        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, tuple<U...>&&);        // constexpr in C++20
    template<class Alloc, class... UTypes>
        constexpr explicit(see-below)
          tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&&);               // C++23
    template<class Alloc, class U1, class U2>
        constexpr explicit(see-below)
          tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&);                          // C++23
    template <class Alloc, class U1, class U2>
        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);  // constexpr in C++20
    template <class Alloc, class U1, class U2>
        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);       // constexpr in C++20
    template<class Alloc, class U1, class U2>
        constexpr explicit(see-below)
          tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&&);                   // C++23

    tuple& operator=(const tuple&);                                                       // constexpr in C++20
    constexpr const tuple& operator=(const tuple&) const;                                 // C++23
    tuple& operator=(tuple&&) noexcept(is_nothrow_move_assignable_v<T> && ...);           // constexpr in C++20
    constexpr const tuple& operator=(tuple&&) const;                                      // C++23
    template <class... U>
        tuple& operator=(const tuple<U...>&);                                             // constexpr in C++20
    template<class... UTypes>
        constexpr const tuple& operator=(const tuple<UTypes...>&) const;                  // C++23
    template <class... U>
        tuple& operator=(tuple<U...>&&);                                                  // constexpr in C++20
    template<class... UTypes>
        constexpr const tuple& operator=(tuple<UTypes...>&&) const;                       // C++23
    template <class U1, class U2>
        tuple& operator=(const pair<U1, U2>&); // iff sizeof...(T) == 2                   // constexpr in C++20
    template<class U1, class U2>
        constexpr const tuple& operator=(const pair<U1, U2>&) const;   // iff sizeof...(Types) == 2 // C++23
    template <class U1, class U2>
        tuple& operator=(pair<U1, U2>&&); // iff sizeof...(T) == 2                        // constexpr in C++20
    template<class U1, class U2>
        constexpr const tuple& operator=(pair<U1, U2>&&) const;  // iff sizeof...(Types) == 2 // C++23

    template<class U, size_t N>
        tuple& operator=(array<U, N> const&) // iff sizeof...(T) == N, EXTENSION
    template<class U, size_t N>
        tuple& operator=(array<U, N>&&) // iff sizeof...(T) == N, EXTENSION

    void swap(tuple&) noexcept(AND(swap(declval<T&>(), declval<T&>())...));               // constexpr in C++20
    constexpr void swap(const tuple&) const noexcept(see-below);                          // C++23
};


template<class... TTypes, class... UTypes, template<class> class TQual, template<class> class UQual> // since C++23
  requires requires { typename tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...>; }
struct basic_common_reference<tuple<TTypes...>, tuple<UTypes...>, TQual, UQual> {
  using type = tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...>;
};

template<class... TTypes, class... UTypes>                                // since C++23
  requires requires { typename tuple<common_type_t<TTypes, UTypes>...>; }
struct common_type<tuple<TTypes...>, tuple<UTypes...>> {
  using type = tuple<common_type_t<TTypes, UTypes>...>;
};

template <class ...T>
tuple(T...) -> tuple<T...>;                                         // since C++17
template <class T1, class T2>
tuple(pair<T1, T2>) -> tuple<T1, T2>;                               // since C++17
template <class Alloc, class ...T>
tuple(allocator_arg_t, Alloc, T...) -> tuple<T...>;                 // since C++17
template <class Alloc, class T1, class T2>
tuple(allocator_arg_t, Alloc, pair<T1, T2>) -> tuple<T1, T2>;       // since C++17
template <class Alloc, class ...T>
tuple(allocator_arg_t, Alloc, tuple<T...>) -> tuple<T...>;          // since C++17

inline constexpr unspecified ignore;

template <class... T> tuple<V...>  make_tuple(T&&...); // constexpr in C++14
template <class... T> tuple<ATypes...> forward_as_tuple(T&&...) noexcept; // constexpr in C++14
template <class... T> tuple<T&...> tie(T&...) noexcept; // constexpr in C++14
template <class... Tuples> tuple<CTypes...> tuple_cat(Tuples&&... tpls); // constexpr in C++14

// [tuple.apply], calling a function with a tuple of arguments:
template <class F, class Tuple>
  constexpr decltype(auto) apply(F&& f, Tuple&& t) noexcept(see below);  // C++17 noexcept since C++23
template <class T, class Tuple>
  constexpr T make_from_tuple(Tuple&& t); // C++17

// 20.4.1.4, tuple helper classes:
template <class T> struct tuple_size; // undefined
template <class... T> struct tuple_size<tuple<T...>>;
template <class T>
 inline constexpr size_t tuple_size_v = tuple_size<T>::value; // C++17
template <size_t I, class T> struct tuple_element; // undefined
template <size_t I, class... T> struct tuple_element<I, tuple<T...>>;
template <size_t I, class T>
  using tuple_element_t = typename tuple_element <I, T>::type; // C++14

// 20.4.1.5, element access:
template <size_t I, class... T>
    typename tuple_element<I, tuple<T...>>::type&
    get(tuple<T...>&) noexcept; // constexpr in C++14
template <size_t I, class... T>
    const typename tuple_element<I, tuple<T...>>::type&
    get(const tuple<T...>&) noexcept; // constexpr in C++14
template <size_t I, class... T>
    typename tuple_element<I, tuple<T...>>::type&&
    get(tuple<T...>&&) noexcept; // constexpr in C++14
template <size_t I, class... T>
    const typename tuple_element<I, tuple<T...>>::type&&
    get(const tuple<T...>&&) noexcept; // constexpr in C++14

template <class T1, class... T>
    constexpr T1& get(tuple<T...>&) noexcept;  // C++14
template <class T1, class... T>
    constexpr const T1& get(const tuple<T...>&) noexcept;   // C++14
template <class T1, class... T>
    constexpr T1&& get(tuple<T...>&&) noexcept;   // C++14
template <class T1, class... T>
    constexpr const T1&& get(const tuple<T...>&&) noexcept;   // C++14

// 20.4.1.6, relational operators:
template<class... T, class... U> bool operator==(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14
template<class... T, class... U> bool operator<(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14, removed in C++20
template<class... T, class... U> bool operator!=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14, removed in C++20
template<class... T, class... U> bool operator>(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14, removed in C++20
template<class... T, class... U> bool operator<=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14, removed in C++20
template<class... T, class... U> bool operator>=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14, removed in C++20
template<class... T, class... U>
  constexpr common_comparison_category_t<synth-three-way-result<T, U>...>
    operator<=>(const tuple<T...>&, const tuple<U...>&);                                  // since C++20

template <class... Types, class Alloc>
  struct uses_allocator<tuple<Types...>, Alloc>;

template <class... Types>
  void
  swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(noexcept(x.swap(y)));

template <class... Types>
  constexpr void swap(const tuple<Types...>& x, const tuple<Types...>& y) noexcept(see-below);   // C++23

}  // std

*/

// clang-format on

#include <__assert> // all public C++ headers provide the assertion handler
#include <__compare/common_comparison_category.h>
#include <__compare/synth_three_way.h>
#include <__config>
#include <__functional/invoke.h>
#include <__fwd/array.h>
#include <__fwd/tuple.h>
#include <__memory/allocator_arg_t.h>
#include <__memory/uses_allocator.h>
#include <__tuple/make_tuple_types.h>
#include <__tuple/sfinae_helpers.h>
#include <__tuple/tuple_element.h>
#include <__tuple/tuple_indices.h>
#include <__tuple/tuple_like_ext.h>
#include <__tuple/tuple_size.h>
#include <__tuple/tuple_types.h>
#include <__type_traits/apply_cv.h>
#include <__type_traits/common_reference.h>
#include <__type_traits/common_type.h>
#include <__type_traits/conditional.h>
#include <__type_traits/conjunction.h>
#include <__type_traits/copy_cvref.h>
#include <__type_traits/disjunction.h>
#include <__type_traits/invoke.h>
#include <__type_traits/is_arithmetic.h>
#include <__type_traits/is_assignable.h>
#include <__type_traits/is_constructible.h>
#include <__type_traits/is_convertible.h>
#include <__type_traits/is_copy_assignable.h>
#include <__type_traits/is_copy_constructible.h>
#include <__type_traits/is_default_constructible.h>
#include <__type_traits/is_empty.h>
#include <__type_traits/is_final.h>
#include <__type_traits/is_implicitly_default_constructible.h>
#include <__type_traits/is_move_assignable.h>
#include <__type_traits/is_move_constructible.h>
#include <__type_traits/is_nothrow_assignable.h>
#include <__type_traits/is_nothrow_constructible.h>
#include <__type_traits/is_nothrow_copy_assignable.h>
#include <__type_traits/is_nothrow_copy_constructible.h>
#include <__type_traits/is_nothrow_default_constructible.h>
#include <__type_traits/is_nothrow_move_assignable.h>
#include <__type_traits/is_reference.h>
#include <__type_traits/is_same.h>
#include <__type_traits/is_swappable.h>
#include <__type_traits/lazy.h>
#include <__type_traits/maybe_const.h>
#include <__type_traits/nat.h>
#include <__type_traits/negation.h>
#include <__type_traits/remove_cvref.h>
#include <__type_traits/remove_reference.h>
#include <__type_traits/unwrap_ref.h>
#include <__utility/forward.h>
#include <__utility/integer_sequence.h>
#include <__utility/move.h>
#include <__utility/pair.h>
#include <__utility/piecewise_construct.h>
#include <__utility/swap.h>
#include <cstddef>
#include <version>

// standard-mandated includes

// [tuple.syn]
#include <compare>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#  pragma GCC system_header
#endif

_LIBCPP_PUSH_MACROS
#include <__undef_macros>

_LIBCPP_BEGIN_NAMESPACE_STD

#ifndef __experimental_tuple
#  ifndef _LIBCPP_CXX03_LANG

// __tuple_leaf

template <size_t _Ip, class _Hp, bool = is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value >
class __tuple_leaf;

template <size_t _Ip, class _Hp, bool _Ep>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void
swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)
    _NOEXCEPT_(__is_nothrow_swappable<_Hp>::value) {
  swap(__x.get(), __y.get());
}

template <size_t _Ip, class _Hp, bool _Ep>
_LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void
swap(const __tuple_leaf<_Ip, _Hp, _Ep>& __x, const __tuple_leaf<_Ip, _Hp, _Ep>& __y)
    _NOEXCEPT_(__is_nothrow_swappable<const _Hp>::value) {
  swap(__x.get(), __y.get());
}

template <size_t _Ip, class _Hp, bool>
class __tuple_leaf {
  _Hp __value_;

  template <class _Tp>
  static _LIBCPP_HIDE_FROM_ABI constexpr bool __can_bind_reference() {
#  if __has_keyword(__reference_binds_to_temporary)
    return !__reference_binds_to_temporary(_Hp, _Tp);
#  else
    return true;
#  endif
  }

  _LIBCPP_CONSTEXPR_SINCE_CXX14 __tuple_leaf& operator=(const __tuple_leaf&);

public:
  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf() _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) : __value_() {
    static_assert(!is_reference<_Hp>::value, "Attempted to default construct a reference element in a tuple");
  }

  template <class _Alloc>
  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf(integral_constant<int, 0>, const _Alloc&) : __value_() {
    static_assert(!is_reference<_Hp>::value, "Attempted to default construct a reference element in a tuple");
  }

  template <class _Alloc>
  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
      : __value_(allocator_arg_t(), __a) {
    static_assert(!is_reference<_Hp>::value, "Attempted to default construct a reference element in a tuple");
  }

  template <class _Alloc>
  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a) : __value_(__a) {
    static_assert(!is_reference<_Hp>::value, "Attempted to default construct a reference element in a tuple");
  }

  template <class _Tp,
            class = __enable_if_t<
                _And< _IsNotSame<__remove_cvref_t<_Tp>, __tuple_leaf>, is_constructible<_Hp, _Tp> >::value > >
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit __tuple_leaf(_Tp&& __t)
      _NOEXCEPT_(is_nothrow_constructible<_Hp, _Tp>::value)
      : __value_(std::forward<_Tp>(__t)) {
    static_assert(__can_bind_reference<_Tp&&>(),
                  "Attempted construction of reference element binds to a temporary whose lifetime has ended");
  }

  template <class _Tp, class _Alloc>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit __tuple_leaf(
      integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
      : __value_(std::forward<_Tp>(__t)) {
    static_assert(__can_bind_reference<_Tp&&>(),
                  "Attempted construction of reference element binds to a temporary whose lifetime has ended");
  }

  template <class _Tp, class _Alloc>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit __tuple_leaf(
      integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
      : __value_(allocator_arg_t(), __a, std::forward<_Tp>(__t)) {
    static_assert(!is_reference<_Hp>::value, "Attempted to uses-allocator construct a reference element in a tuple");
  }

  template <class _Tp, class _Alloc>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit __tuple_leaf(
      integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
      : __value_(std::forward<_Tp>(__t), __a) {
    static_assert(!is_reference<_Hp>::value, "Attempted to uses-allocator construct a reference element in a tuple");
  }

  _LIBCPP_HIDE_FROM_ABI __tuple_leaf(const __tuple_leaf& __t) = default;
  _LIBCPP_HIDE_FROM_ABI __tuple_leaf(__tuple_leaf&& __t)      = default;

  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 int swap(__tuple_leaf& __t)
      _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value) {
    std::swap(*this, __t);
    return 0;
  }

  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 int swap(const __tuple_leaf& __t) const
      _NOEXCEPT_(__is_nothrow_swappable<const __tuple_leaf>::value) {
    std::swap(*this, __t);
    return 0;
  }

  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 _Hp& get() _NOEXCEPT { return __value_; }
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 const _Hp& get() const _NOEXCEPT { return __value_; }
};

template <size_t _Ip, class _Hp>
class __tuple_leaf<_Ip, _Hp, true> : private _Hp {
  _LIBCPP_CONSTEXPR_SINCE_CXX14 __tuple_leaf& operator=(const __tuple_leaf&);

public:
  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf() _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) {}

  template <class _Alloc>
  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}

  template <class _Alloc>
  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
      : _Hp(allocator_arg_t(), __a) {}

  template <class _Alloc>
  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a) : _Hp(__a) {}

  template <class _Tp,
            class = __enable_if_t<
                _And< _IsNotSame<__remove_cvref_t<_Tp>, __tuple_leaf>, is_constructible<_Hp, _Tp> >::value > >
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit __tuple_leaf(_Tp&& __t)
      _NOEXCEPT_(is_nothrow_constructible<_Hp, _Tp>::value)
      : _Hp(std::forward<_Tp>(__t)) {}

  template <class _Tp, class _Alloc>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
      : _Hp(std::forward<_Tp>(__t)) {}

  template <class _Tp, class _Alloc>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
      : _Hp(allocator_arg_t(), __a, std::forward<_Tp>(__t)) {}

  template <class _Tp, class _Alloc>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
      : _Hp(std::forward<_Tp>(__t), __a) {}

  __tuple_leaf(__tuple_leaf const&) = default;
  __tuple_leaf(__tuple_leaf&&)      = default;

  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 int swap(__tuple_leaf& __t)
      _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value) {
    std::swap(*this, __t);
    return 0;
  }

  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 int swap(const __tuple_leaf& __rhs) const
      _NOEXCEPT_(__is_nothrow_swappable<const __tuple_leaf>::value) {
    std::swap(*this, __rhs);
    return 0;
  }

  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 _Hp& get() _NOEXCEPT { return static_cast<_Hp&>(*this); }
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 const _Hp& get() const _NOEXCEPT {
    return static_cast<const _Hp&>(*this);
  }
};

template <class... _Tp>
_LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void __swallow(_Tp&&...) _NOEXCEPT {}

template <class _Tp>
struct __all_default_constructible;

template <class... _Tp>
struct __all_default_constructible<__tuple_types<_Tp...>> : __all<is_default_constructible<_Tp>::value...> {};

// __tuple_impl

template <class _Indx, class... _Tp>
struct __tuple_impl;

template <size_t... _Indx, class... _Tp>
struct _LIBCPP_DECLSPEC_EMPTY_BASES __tuple_impl<__tuple_indices<_Indx...>, _Tp...>
    : public __tuple_leaf<_Indx, _Tp>... {
  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_impl()
      _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}

  template <size_t... _Uf, class... _Tf, size_t... _Ul, class... _Tl, class... _Up>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit __tuple_impl(
      __tuple_indices<_Uf...>, __tuple_types<_Tf...>, __tuple_indices<_Ul...>, __tuple_types<_Tl...>, _Up&&... __u)
      _NOEXCEPT_(__all<is_nothrow_constructible<_Tf, _Up>::value...>::value&&
                     __all<is_nothrow_default_constructible<_Tl>::value...>::value)
      : __tuple_leaf<_Uf, _Tf>(std::forward<_Up>(__u))..., __tuple_leaf<_Ul, _Tl>()... {}

  template <class _Alloc, size_t... _Uf, class... _Tf, size_t... _Ul, class... _Tl, class... _Up>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit __tuple_impl(
      allocator_arg_t,
      const _Alloc& __a,
      __tuple_indices<_Uf...>,
      __tuple_types<_Tf...>,
      __tuple_indices<_Ul...>,
      __tuple_types<_Tl...>,
      _Up&&... __u)
      : __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a, std::forward<_Up>(__u))...,
        __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)... {}

  template <class _Tuple, class = __enable_if_t<__tuple_constructible<_Tuple, tuple<_Tp...> >::value> >
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 __tuple_impl(_Tuple&& __t) _NOEXCEPT_(
      (__all<is_nothrow_constructible<
           _Tp,
           typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))
      : __tuple_leaf<_Indx, _Tp>(
            std::forward<typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>(
                std::get<_Indx>(__t)))... {}

  template <class _Alloc, class _Tuple, class = __enable_if_t<__tuple_constructible<_Tuple, tuple<_Tp...> >::value> >
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
      : __tuple_leaf<_Indx, _Tp>(
            __uses_alloc_ctor<_Tp,
                              _Alloc,
                              typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>(),
            __a,
            std::forward<typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>(
                std::get<_Indx>(__t)))... {}

  __tuple_impl(const __tuple_impl&) = default;
  __tuple_impl(__tuple_impl&&)      = default;

  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void swap(__tuple_impl& __t)
      _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value) {
    std::__swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);
  }

  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void swap(const __tuple_impl& __t) const
      _NOEXCEPT_(__all<__is_nothrow_swappable<const _Tp>::value...>::value) {
    std::__swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t))...);
  }
};

template <class _Dest, class _Source, size_t... _Np>
_LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void
__memberwise_copy_assign(_Dest& __dest, _Source const& __source, __tuple_indices<_Np...>) {
  std::__swallow(((std::get<_Np>(__dest) = std::get<_Np>(__source)), void(), 0)...);
}

template <class _Dest, class _Source, class... _Up, size_t... _Np>
_LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void
__memberwise_forward_assign(_Dest& __dest, _Source&& __source, __tuple_types<_Up...>, __tuple_indices<_Np...>) {
  std::__swallow(((std::get<_Np>(__dest) = std::forward<_Up>(std::get<_Np>(__source))), void(), 0)...);
}

template <class... _Tp>
class _LIBCPP_TEMPLATE_VIS tuple {
  typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> _BaseT;

  _BaseT __base_;

  template <size_t _Jp, class... _Up>
  friend _LIBCPP_CONSTEXPR_SINCE_CXX14 typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) _NOEXCEPT;
  template <size_t _Jp, class... _Up>
  friend _LIBCPP_CONSTEXPR_SINCE_CXX14 const typename tuple_element<_Jp, tuple<_Up...> >::type&
  get(const tuple<_Up...>&) _NOEXCEPT;
  template <size_t _Jp, class... _Up>
  friend _LIBCPP_CONSTEXPR_SINCE_CXX14 typename tuple_element<_Jp, tuple<_Up...> >::type&&
  get(tuple<_Up...>&&) _NOEXCEPT;
  template <size_t _Jp, class... _Up>
  friend _LIBCPP_CONSTEXPR_SINCE_CXX14 const typename tuple_element<_Jp, tuple<_Up...> >::type&&
  get(const tuple<_Up...>&&) _NOEXCEPT;

public:
  // [tuple.cnstr]

  _LIBCPP_DIAGNOSTIC_PUSH
  _LIBCPP_CLANG_DIAGNOSTIC_IGNORED("-Wc++20-extensions")
  _LIBCPP_GCC_DIAGNOSTIC_IGNORED("-Wc++20-extensions")

  // tuple() constructors (including allocator_arg_t variants)
  template <template <class...> class _IsImpDefault                = __is_implicitly_default_constructible,
            template <class...> class _IsDefault                   = is_default_constructible,
            __enable_if_t< _And< _IsDefault<_Tp>... >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR explicit(_Not<_Lazy<_And, _IsImpDefault<_Tp>...> >::value) tuple()
      _NOEXCEPT_(_And<is_nothrow_default_constructible<_Tp>...>::value) {}

  template <class _Alloc,
            template <class...> class _IsImpDefault                = __is_implicitly_default_constructible,
            template <class...> class _IsDefault                   = is_default_constructible,
            __enable_if_t< _And< _IsDefault<_Tp>... >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 explicit(_Not<_Lazy<_And, _IsImpDefault<_Tp>...> >::value)
      tuple(allocator_arg_t, _Alloc const& __a)
      : __base_(allocator_arg_t(),
                __a,
                __tuple_indices<>(),
                __tuple_types<>(),
                typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
                __tuple_types<_Tp...>()) {}

  // tuple(const T&...) constructors (including allocator_arg_t variants)
  template <template <class...> class _And = _And,
            __enable_if_t< _And< _BoolConstant<sizeof...(_Tp) >= 1>, is_copy_constructible<_Tp>... >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit(
      _Not<_Lazy<_And, is_convertible<const _Tp&, _Tp>...> >::value) tuple(const _Tp&... __t)
      _NOEXCEPT_(_And<is_nothrow_copy_constructible<_Tp>...>::value)
      : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...) {}

  template <class _Alloc,
            template <class...> class _And = _And,
            __enable_if_t< _And< _BoolConstant<sizeof...(_Tp) >= 1>, is_copy_constructible<_Tp>... >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 explicit(
      _Not<_Lazy<_And, is_convertible<const _Tp&, _Tp>...> >::value)
      tuple(allocator_arg_t, const _Alloc& __a, const _Tp&... __t)
      : __base_(allocator_arg_t(),
                __a,
                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...) {}

  // tuple(U&& ...) constructors (including allocator_arg_t variants)
  template <class... _Up>
  struct _IsThisTuple : false_type {};
  template <class _Up>
  struct _IsThisTuple<_Up> : is_same<__remove_cvref_t<_Up>, tuple> {};

  template <class... _Up>
  struct _EnableUTypesCtor
      : _And< _BoolConstant<sizeof...(_Tp) >= 1>,
              _Not<_IsThisTuple<_Up...> >, // extension to allow mis-behaved user constructors
              is_constructible<_Tp, _Up>... > {};

  template <class... _Up,
            __enable_if_t< _And< _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>, _EnableUTypesCtor<_Up...> >::value,
                           int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit(_Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >::value)
      tuple(_Up&&... __u) _NOEXCEPT_(_And<is_nothrow_constructible<_Tp, _Up>...>::value)
      : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                std::forward<_Up>(__u)...) {}

  template <class _Alloc,
            class... _Up,
            __enable_if_t< _And< _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>, _EnableUTypesCtor<_Up...> >::value,
                           int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 explicit(_Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >::value)
      tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
      : __base_(allocator_arg_t(),
                __a,
                typename __make_tuple_indices<sizeof...(_Up)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                std::forward<_Up>(__u)...) {}

  // Copy and move constructors (including the allocator_arg_t variants)
  tuple(const tuple&) = default;
  tuple(tuple&&)      = default;

  template <class _Alloc,
            template <class...> class _And                                  = _And,
            __enable_if_t< _And<is_copy_constructible<_Tp>...>::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple(allocator_arg_t, const _Alloc& __alloc, const tuple& __t)
      : __base_(allocator_arg_t(), __alloc, __t) {}

  template <class _Alloc,
            template <class...> class _And                                  = _And,
            __enable_if_t< _And<is_move_constructible<_Tp>...>::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple(allocator_arg_t, const _Alloc& __alloc, tuple&& __t)
      : __base_(allocator_arg_t(), __alloc, std::move(__t)) {}

  // tuple(const tuple<U...>&) constructors (including allocator_arg_t variants)

  template <class _OtherTuple, class _DecayedOtherTuple = __remove_cvref_t<_OtherTuple>, class = void>
  struct _EnableCtorFromUTypesTuple : false_type {};

  template <class _OtherTuple, class... _Up>
  struct _EnableCtorFromUTypesTuple<
      _OtherTuple,
      tuple<_Up...>,
      // the length of the packs needs to checked first otherwise the 2 packs cannot be expanded simultaneously below
      __enable_if_t<sizeof...(_Up) == sizeof...(_Tp)>>
      : _And<
            // the two conditions below are not in spec. The purpose is to disable the UTypes Ctor when copy/move Ctor
            // can work. Otherwise, is_constructible can trigger hard error in those cases
            // https://godbolt.org/z/M94cGdKcE
            _Not<is_same<_OtherTuple, const tuple&> >,
            _Not<is_same<_OtherTuple, tuple&&> >,
            is_constructible<_Tp, __copy_cvref_t<_OtherTuple, _Up> >...,
            _Lazy<_Or,
                  _BoolConstant<sizeof...(_Tp) != 1>,
                  // _Tp and _Up are 1-element packs - the pack expansions look
                  // weird to avoid tripping up the type traits in degenerate cases
                  _Lazy<_And,
                        _Not<is_same<_Tp, _Up> >...,
                        _Not<is_convertible<_OtherTuple, _Tp> >...,
                        _Not<is_constructible<_Tp, _OtherTuple> >... > > > {};

  template <class... _Up, __enable_if_t< _And< _EnableCtorFromUTypesTuple<const tuple<_Up...>&> >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit(
      _Not<_Lazy<_And, is_convertible<const _Up&, _Tp>...> >::value) tuple(const tuple<_Up...>& __t)
      _NOEXCEPT_(_And<is_nothrow_constructible<_Tp, const _Up&>...>::value)
      : __base_(__t) {}

  template <class... _Up,
            class _Alloc,
            __enable_if_t< _And< _EnableCtorFromUTypesTuple<const tuple<_Up...>&> >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 explicit(
      _Not<_Lazy<_And, is_convertible<const _Up&, _Tp>...> >::value)
      tuple(allocator_arg_t, const _Alloc& __a, const tuple<_Up...>& __t)
      : __base_(allocator_arg_t(), __a, __t) {}

#  if _LIBCPP_STD_VER >= 23
  // tuple(tuple<U...>&) constructors (including allocator_arg_t variants)

  template <class... _Up, enable_if_t< _EnableCtorFromUTypesTuple<tuple<_Up...>&>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_Lazy<_And, is_convertible<_Up&, _Tp>...>::value) tuple(tuple<_Up...>& __t)
      : __base_(__t) {}

  template <class _Alloc, class... _Up, enable_if_t< _EnableCtorFromUTypesTuple<tuple<_Up...>&>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_Lazy<_And, is_convertible<_Up&, _Tp>...>::value)
      tuple(allocator_arg_t, const _Alloc& __alloc, tuple<_Up...>& __t)
      : __base_(allocator_arg_t(), __alloc, __t) {}
#  endif // _LIBCPP_STD_VER >= 23

  // tuple(tuple<U...>&&) constructors (including allocator_arg_t variants)
  template <class... _Up, __enable_if_t< _And< _EnableCtorFromUTypesTuple<tuple<_Up...>&&> >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit(_Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >::value)
      tuple(tuple<_Up...>&& __t) _NOEXCEPT_(_And<is_nothrow_constructible<_Tp, _Up>...>::value)
      : __base_(std::move(__t)) {}

  template <class _Alloc,
            class... _Up,
            __enable_if_t< _And< _EnableCtorFromUTypesTuple<tuple<_Up...>&&> >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 explicit(_Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >::value)
      tuple(allocator_arg_t, const _Alloc& __a, tuple<_Up...>&& __t)
      : __base_(allocator_arg_t(), __a, std::move(__t)) {}

#  if _LIBCPP_STD_VER >= 23
  // tuple(const tuple<U...>&&) constructors (including allocator_arg_t variants)

  template <class... _Up, enable_if_t< _EnableCtorFromUTypesTuple<const tuple<_Up...>&&>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_Lazy<_And, is_convertible<const _Up&&, _Tp>...>::value)
      tuple(const tuple<_Up...>&& __t)
      : __base_(std::move(__t)) {}

  template <class _Alloc,
            class... _Up,
            enable_if_t< _EnableCtorFromUTypesTuple<const tuple<_Up...>&&>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_Lazy<_And, is_convertible<const _Up&&, _Tp>...>::value)
      tuple(allocator_arg_t, const _Alloc& __alloc, const tuple<_Up...>&& __t)
      : __base_(allocator_arg_t(), __alloc, std::move(__t)) {}
#  endif // _LIBCPP_STD_VER >= 23

  // tuple(const pair<U1, U2>&) constructors (including allocator_arg_t variants)

  template <template <class...> class _Pred,
            class _Pair,
            class _DecayedPair = __remove_cvref_t<_Pair>,
            class _Tuple       = tuple>
  struct _CtorPredicateFromPair : false_type {};

  template <template <class...> class _Pred, class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
  struct _CtorPredicateFromPair<_Pred, _Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> >
      : _And< _Pred<_Tp1, __copy_cvref_t<_Pair, _Up1> >, _Pred<_Tp2, __copy_cvref_t<_Pair, _Up2> > > {};

  template <class _Pair>
  struct _EnableCtorFromPair : _CtorPredicateFromPair<is_constructible, _Pair> {};

  template <class _Pair>
  struct _NothrowConstructibleFromPair : _CtorPredicateFromPair<is_nothrow_constructible, _Pair> {};

  template <class _Pair, class _DecayedPair = __remove_cvref_t<_Pair>, class _Tuple = tuple>
  struct _BothImplicitlyConvertible : false_type {};

  template <class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
  struct _BothImplicitlyConvertible<_Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> >
      : _And< is_convertible<__copy_cvref_t<_Pair, _Up1>, _Tp1>, is_convertible<__copy_cvref_t<_Pair, _Up2>, _Tp2> > {};

  template <class _Up1,
            class _Up2,
            template <class...> class _And                                                   = _And,
            __enable_if_t< _And< _EnableCtorFromPair<const pair<_Up1, _Up2>&> >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit(
      _Not<_BothImplicitlyConvertible<const pair<_Up1, _Up2>&> >::value) tuple(const pair<_Up1, _Up2>& __p)
      _NOEXCEPT_(_NothrowConstructibleFromPair<const pair<_Up1, _Up2>&>::value)
      : __base_(__p) {}

  template <class _Alloc,
            class _Up1,
            class _Up2,
            template <class...> class _And                                                   = _And,
            __enable_if_t< _And< _EnableCtorFromPair<const pair<_Up1, _Up2>&> >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 explicit(
      _Not<_BothImplicitlyConvertible<const pair<_Up1, _Up2>&> >::value)
      tuple(allocator_arg_t, const _Alloc& __a, const pair<_Up1, _Up2>& __p)
      : __base_(allocator_arg_t(), __a, __p) {}

#  if _LIBCPP_STD_VER >= 23
  // tuple(pair<U1, U2>&) constructors (including allocator_arg_t variants)

  template <class _U1, class _U2, enable_if_t< _EnableCtorFromPair<pair<_U1, _U2>&>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_BothImplicitlyConvertible<pair<_U1, _U2>&>::value)
      tuple(pair<_U1, _U2>& __p)
      : __base_(__p) {}

  template <class _Alloc,
            class _U1,
            class _U2,
            enable_if_t< _EnableCtorFromPair<std::pair<_U1, _U2>&>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_BothImplicitlyConvertible<pair<_U1, _U2>&>::value)
      tuple(allocator_arg_t, const _Alloc& __alloc, pair<_U1, _U2>& __p)
      : __base_(allocator_arg_t(), __alloc, __p) {}
#  endif

  // tuple(pair<U1, U2>&&) constructors (including allocator_arg_t variants)

  template <class _Up1,
            class _Up2,
            template <class...> class _And                                              = _And,
            __enable_if_t< _And< _EnableCtorFromPair<pair<_Up1, _Up2>&&> >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit(
      _Not<_BothImplicitlyConvertible<pair<_Up1, _Up2>&&> >::value) tuple(pair<_Up1, _Up2>&& __p)
      _NOEXCEPT_(_NothrowConstructibleFromPair<pair<_Up1, _Up2>&&>::value)
      : __base_(std::move(__p)) {}

  template <class _Alloc,
            class _Up1,
            class _Up2,
            template <class...> class _And                                              = _And,
            __enable_if_t< _And< _EnableCtorFromPair<pair<_Up1, _Up2>&&> >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 explicit(
      _Not<_BothImplicitlyConvertible<pair<_Up1, _Up2>&&> >::value)
      tuple(allocator_arg_t, const _Alloc& __a, pair<_Up1, _Up2>&& __p)
      : __base_(allocator_arg_t(), __a, std::move(__p)) {}

#  if _LIBCPP_STD_VER >= 23
  // tuple(const pair<U1, U2>&&) constructors (including allocator_arg_t variants)

  template <class _U1, class _U2, enable_if_t< _EnableCtorFromPair<const pair<_U1, _U2>&&>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_BothImplicitlyConvertible<const pair<_U1, _U2>&&>::value)
      tuple(const pair<_U1, _U2>&& __p)
      : __base_(std::move(__p)) {}

  template <class _Alloc,
            class _U1,
            class _U2,
            enable_if_t< _EnableCtorFromPair<const pair<_U1, _U2>&&>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_BothImplicitlyConvertible<const pair<_U1, _U2>&&>::value)
      tuple(allocator_arg_t, const _Alloc& __alloc, const pair<_U1, _U2>&& __p)
      : __base_(allocator_arg_t(), __alloc, std::move(__p)) {}
#  endif // _LIBCPP_STD_VER >= 23

  _LIBCPP_DIAGNOSTIC_POP

  // [tuple.assign]
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple&
  operator=(_If<_And<is_copy_assignable<_Tp>...>::value, tuple, __nat> const& __tuple)
      _NOEXCEPT_(_And<is_nothrow_copy_assignable<_Tp>...>::value) {
    std::__memberwise_copy_assign(*this, __tuple, typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }

#  if _LIBCPP_STD_VER >= 23
  _LIBCPP_HIDE_FROM_ABI constexpr const tuple& operator=(tuple const& __tuple) const
    requires(_And<is_copy_assignable<const _Tp>...>::value)
  {
    std::__memberwise_copy_assign(*this, __tuple, typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }

  _LIBCPP_HIDE_FROM_ABI constexpr const tuple& operator=(tuple&& __tuple) const
    requires(_And<is_assignable<const _Tp&, _Tp>...>::value)
  {
    std::__memberwise_forward_assign(
        *this, std::move(__tuple), __tuple_types<_Tp...>(), typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }
#  endif // _LIBCPP_STD_VER >= 23

  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple&
  operator=(_If<_And<is_move_assignable<_Tp>...>::value, tuple, __nat>&& __tuple)
      _NOEXCEPT_(_And<is_nothrow_move_assignable<_Tp>...>::value) {
    std::__memberwise_forward_assign(
        *this, std::move(__tuple), __tuple_types<_Tp...>(), typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }

  template <
      class... _Up,
      __enable_if_t< _And< _BoolConstant<sizeof...(_Tp) == sizeof...(_Up)>, is_assignable<_Tp&, _Up const&>... >::value,
                     int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple& operator=(tuple<_Up...> const& __tuple)
      _NOEXCEPT_(_And<is_nothrow_assignable<_Tp&, _Up const&>...>::value) {
    std::__memberwise_copy_assign(*this, __tuple, typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }

  template <class... _Up,
            __enable_if_t< _And< _BoolConstant<sizeof...(_Tp) == sizeof...(_Up)>, is_assignable<_Tp&, _Up>... >::value,
                           int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple& operator=(tuple<_Up...>&& __tuple)
      _NOEXCEPT_(_And<is_nothrow_assignable<_Tp&, _Up>...>::value) {
    std::__memberwise_forward_assign(
        *this, std::move(__tuple), __tuple_types<_Up...>(), typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }

#  if _LIBCPP_STD_VER >= 23
  template <class... _UTypes,
            enable_if_t< _And<_BoolConstant<sizeof...(_Tp) == sizeof...(_UTypes)>,
                              is_assignable<const _Tp&, const _UTypes&>...>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr const tuple& operator=(const tuple<_UTypes...>& __u) const {
    std::__memberwise_copy_assign(*this, __u, typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }

  template <class... _UTypes,
            enable_if_t< _And<_BoolConstant<sizeof...(_Tp) == sizeof...(_UTypes)>,
                              is_assignable<const _Tp&, _UTypes>...>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr const tuple& operator=(tuple<_UTypes...>&& __u) const {
    std::__memberwise_forward_assign(
        *this, __u, __tuple_types<_UTypes...>(), typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }
#  endif // _LIBCPP_STD_VER >= 23

  template <template <class...> class _Pred,
            bool _Const,
            class _Pair,
            class _DecayedPair = __remove_cvref_t<_Pair>,
            class _Tuple       = tuple>
  struct _AssignPredicateFromPair : false_type {};

  template <template <class...> class _Pred, bool _Const, class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
  struct _AssignPredicateFromPair<_Pred, _Const, _Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> >
      : _And<_Pred<__maybe_const<_Const, _Tp1>&, __copy_cvref_t<_Pair, _Up1> >,
             _Pred<__maybe_const<_Const, _Tp2>&, __copy_cvref_t<_Pair, _Up2> > > {};

  template <bool _Const, class _Pair>
  struct _EnableAssignFromPair : _AssignPredicateFromPair<is_assignable, _Const, _Pair> {};

  template <bool _Const, class _Pair>
  struct _NothrowAssignFromPair : _AssignPredicateFromPair<is_nothrow_assignable, _Const, _Pair> {};

#  if _LIBCPP_STD_VER >= 23
  template <class _U1, class _U2, enable_if_t< _EnableAssignFromPair<true, const pair<_U1, _U2>&>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr const tuple& operator=(const pair<_U1, _U2>& __pair) const
      noexcept(_NothrowAssignFromPair<true, const pair<_U1, _U2>&>::value) {
    std::get<0>(*this) = __pair.first;
    std::get<1>(*this) = __pair.second;
    return *this;
  }

  template <class _U1, class _U2, enable_if_t< _EnableAssignFromPair<true, pair<_U1, _U2>&&>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr const tuple& operator=(pair<_U1, _U2>&& __pair) const
      noexcept(_NothrowAssignFromPair<true, pair<_U1, _U2>&&>::value) {
    std::get<0>(*this) = std::move(__pair.first);
    std::get<1>(*this) = std::move(__pair.second);
    return *this;
  }
#  endif // _LIBCPP_STD_VER >= 23

  template <class _Up1,
            class _Up2,
            __enable_if_t< _EnableAssignFromPair<false, pair<_Up1, _Up2> const&>::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple& operator=(pair<_Up1, _Up2> const& __pair)
      _NOEXCEPT_(_NothrowAssignFromPair<false, pair<_Up1, _Up2> const&>::value) {
    std::get<0>(*this) = __pair.first;
    std::get<1>(*this) = __pair.second;
    return *this;
  }

  template <class _Up1, class _Up2, __enable_if_t< _EnableAssignFromPair<false, pair<_Up1, _Up2>&&>::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple& operator=(pair<_Up1, _Up2>&& __pair)
      _NOEXCEPT_(_NothrowAssignFromPair<false, pair<_Up1, _Up2>&&>::value) {
    std::get<0>(*this) = std::forward<_Up1>(__pair.first);
    std::get<1>(*this) = std::forward<_Up2>(__pair.second);
    return *this;
  }

  // EXTENSION
  template <
      class _Up,
      size_t _Np,
      class = __enable_if_t< _And< _BoolConstant<_Np == sizeof...(_Tp)>, is_assignable<_Tp&, _Up const&>... >::value > >
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple& operator=(array<_Up, _Np> const& __array)
      _NOEXCEPT_(_And<is_nothrow_assignable<_Tp&, _Up const&>...>::value) {
    std::__memberwise_copy_assign(*this, __array, typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }

  // EXTENSION
  template <class _Up,
            size_t _Np,
            class = void,
            class = __enable_if_t< _And< _BoolConstant<_Np == sizeof...(_Tp)>, is_assignable<_Tp&, _Up>... >::value > >
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple& operator=(array<_Up, _Np>&& __array)
      _NOEXCEPT_(_And<is_nothrow_assignable<_Tp&, _Up>...>::value) {
    std::__memberwise_forward_assign(
        *this,
        std::move(__array),
        __tuple_types<_If<true, _Up, _Tp>...>(),
        typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }

  // [tuple.swap]
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 void swap(tuple& __t)
      _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value) {
    __base_.swap(__t.__base_);
  }

#  if _LIBCPP_STD_VER >= 23
  _LIBCPP_HIDE_FROM_ABI constexpr void swap(const tuple& __t) const
      noexcept(__all<is_nothrow_swappable_v<const _Tp&>...>::value) {
    __base_.swap(__t.__base_);
  }
#  endif // _LIBCPP_STD_VER >= 23
};

template <>
class _LIBCPP_TEMPLATE_VIS tuple<> {
public:
  constexpr tuple() _NOEXCEPT = default;
  template <class _Alloc>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT {}
  template <class _Alloc>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT {}
  template <class _Up>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple(array<_Up, 0>) _NOEXCEPT {}
  template <class _Alloc, class _Up>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) _NOEXCEPT {}
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 void swap(tuple&) _NOEXCEPT {}
#  if _LIBCPP_STD_VER >= 23
  _LIBCPP_HIDE_FROM_ABI constexpr void swap(const tuple&) const noexcept {}
#  endif
};

#  if _LIBCPP_STD_VER >= 23
template <class... _TTypes, class... _UTypes, template <class> class _TQual, template <class> class _UQual>
  requires requires { typename tuple<common_reference_t<_TQual<_TTypes>, _UQual<_UTypes>>...>; }
struct basic_common_reference<tuple<_TTypes...>, tuple<_UTypes...>, _TQual, _UQual> {
  using type = tuple<common_reference_t<_TQual<_TTypes>, _UQual<_UTypes>>...>;
};

template <class... _TTypes, class... _UTypes>
  requires requires { typename tuple<common_type_t<_TTypes, _UTypes>...>; }
struct common_type<tuple<_TTypes...>, tuple<_UTypes...>> {
  using type = tuple<common_type_t<_TTypes, _UTypes>...>;
};
#  endif // _LIBCPP_STD_VER >= 23

#  if _LIBCPP_STD_VER >= 17
template <class... _Tp>
tuple(_Tp...) -> tuple<_Tp...>;
template <class _Tp1, class _Tp2>
tuple(pair<_Tp1, _Tp2>) -> tuple<_Tp1, _Tp2>;
template <class _Alloc, class... _Tp>
tuple(allocator_arg_t, _Alloc, _Tp...) -> tuple<_Tp...>;
template <class _Alloc, class _Tp1, class _Tp2>
tuple(allocator_arg_t, _Alloc, pair<_Tp1, _Tp2>) -> tuple<_Tp1, _Tp2>;
template <class _Alloc, class... _Tp>
tuple(allocator_arg_t, _Alloc, tuple<_Tp...>) -> tuple<_Tp...>;
#  endif

template <class... _Tp, __enable_if_t<__all<__is_swappable<_Tp>::value...>::value, int> = 0>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 void swap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)
    _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value) {
  __t.swap(__u);
}

#  if _LIBCPP_STD_VER >= 23
template <class... _Tp>
_LIBCPP_HIDE_FROM_ABI constexpr enable_if_t<__all<is_swappable_v<const _Tp>...>::value, void>
swap(const tuple<_Tp...>& __lhs,
     const tuple<_Tp...>& __rhs) noexcept(__all<is_nothrow_swappable_v<const _Tp>...>::value) {
  __lhs.swap(__rhs);
}
#  endif

// get

template <size_t _Ip, class... _Tp>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>& __t) _NOEXCEPT {
  typedef _LIBCPP_NODEBUG typename tuple_element<_Ip, tuple<_Tp...> >::type type;
  return static_cast<__tuple_leaf<_Ip, type>&>(__t.__base_).get();
}

template <size_t _Ip, class... _Tp>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>& __t) _NOEXCEPT {
  typedef _LIBCPP_NODEBUG typename tuple_element<_Ip, tuple<_Tp...> >::type type;
  return static_cast<const __tuple_leaf<_Ip, type>&>(__t.__base_).get();
}

template <size_t _Ip, class... _Tp>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&& __t) _NOEXCEPT {
  typedef _LIBCPP_NODEBUG typename tuple_element<_Ip, tuple<_Tp...> >::type type;
  return static_cast<type&&>(static_cast<__tuple_leaf<_Ip, type>&&>(__t.__base_).get());
}

template <size_t _Ip, class... _Tp>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&& __t) _NOEXCEPT {
  typedef _LIBCPP_NODEBUG typename tuple_element<_Ip, tuple<_Tp...> >::type type;
  return static_cast<const type&&>(static_cast<const __tuple_leaf<_Ip, type>&&>(__t.__base_).get());
}

#  if _LIBCPP_STD_VER >= 14

namespace __find_detail {

static constexpr size_t __not_found = static_cast<size_t>(-1);
static constexpr size_t __ambiguous = __not_found - 1;

inline _LIBCPP_HIDE_FROM_ABI constexpr size_t __find_idx_return(size_t __curr_i, size_t __res, bool __matches) {
  return !__matches ? __res : (__res == __not_found ? __curr_i : __ambiguous);
}

template <size_t _Nx>
inline _LIBCPP_HIDE_FROM_ABI constexpr size_t __find_idx(size_t __i, const bool (&__matches)[_Nx]) {
  return __i == _Nx
           ? __not_found
           : __find_detail::__find_idx_return(__i, __find_detail::__find_idx(__i + 1, __matches), __matches[__i]);
}

template <class _T1, class... _Args>
struct __find_exactly_one_checked {
  static constexpr bool __matches[sizeof...(_Args)] = {is_same<_T1, _Args>::value...};
  static constexpr size_t value                     = __find_detail::__find_idx(0, __matches);
  static_assert(value != __not_found, "type not found in type list");
  static_assert(value != __ambiguous, "type occurs more than once in type list");
};

template <class _T1>
struct __find_exactly_one_checked<_T1> {
  static_assert(!is_same<_T1, _T1>::value, "type not in empty type list");
};

} // namespace __find_detail

template <typename _T1, typename... _Args>
struct __find_exactly_one_t : public __find_detail::__find_exactly_one_checked<_T1, _Args...> {};

template <class _T1, class... _Args>
inline _LIBCPP_HIDE_FROM_ABI constexpr _T1& get(tuple<_Args...>& __tup) noexcept {
  return std::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}

template <class _T1, class... _Args>
inline _LIBCPP_HIDE_FROM_ABI constexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept {
  return std::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}

template <class _T1, class... _Args>
inline _LIBCPP_HIDE_FROM_ABI constexpr _T1&& get(tuple<_Args...>&& __tup) noexcept {
  return std::get<__find_exactly_one_t<_T1, _Args...>::value>(std::move(__tup));
}

template <class _T1, class... _Args>
inline _LIBCPP_HIDE_FROM_ABI constexpr _T1 const&& get(tuple<_Args...> const&& __tup) noexcept {
  return std::get<__find_exactly_one_t<_T1, _Args...>::value>(std::move(__tup));
}

#  endif

// tie

template <class... _Tp>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 tuple<_Tp&...> tie(_Tp&... __t) _NOEXCEPT {
  return tuple<_Tp&...>(__t...);
}

template <class _Up>
struct __ignore_t {
  template <class _Tp>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 const __ignore_t& operator=(_Tp&&) const {
    return *this;
  }
};

#  if _LIBCPP_STD_VER >= 17
inline constexpr __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>();
#  else
namespace {
constexpr __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>();
} // namespace
#  endif

template <class... _Tp>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 tuple<typename __unwrap_ref_decay<_Tp>::type...>
make_tuple(_Tp&&... __t) {
  return tuple<typename __unwrap_ref_decay<_Tp>::type...>(std::forward<_Tp>(__t)...);
}

template <class... _Tp>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 tuple<_Tp&&...> forward_as_tuple(_Tp&&... __t) _NOEXCEPT {
  return tuple<_Tp&&...>(std::forward<_Tp>(__t)...);
}

template <size_t _Ip>
struct __tuple_equal {
  template <class _Tp, class _Up>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool operator()(const _Tp& __x, const _Up& __y) {
    return __tuple_equal<_Ip - 1>()(__x, __y) && std::get<_Ip - 1>(__x) == std::get<_Ip - 1>(__y);
  }
};

template <>
struct __tuple_equal<0> {
  template <class _Tp, class _Up>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool operator()(const _Tp&, const _Up&) {
    return true;
  }
};

template <class... _Tp, class... _Up>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool
operator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
  static_assert(sizeof...(_Tp) == sizeof...(_Up), "Can't compare tuples of different sizes");
  return __tuple_equal<sizeof...(_Tp)>()(__x, __y);
}

#  if _LIBCPP_STD_VER >= 20

// operator<=>

template <class... _Tp, class... _Up, size_t... _Is>
_LIBCPP_HIDE_FROM_ABI constexpr auto
__tuple_compare_three_way(const tuple<_Tp...>& __x, const tuple<_Up...>& __y, index_sequence<_Is...>) {
  common_comparison_category_t<__synth_three_way_result<_Tp, _Up>...> __result = strong_ordering::equal;
  static_cast<void>(
      ((__result = std::__synth_three_way(std::get<_Is>(__x), std::get<_Is>(__y)), __result != 0) || ...));
  return __result;
}

template <class... _Tp, class... _Up>
  requires(sizeof...(_Tp) == sizeof...(_Up))
_LIBCPP_HIDE_FROM_ABI constexpr common_comparison_category_t<__synth_three_way_result<_Tp, _Up>...>
operator<=>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
  return std::__tuple_compare_three_way(__x, __y, index_sequence_for<_Tp...>{});
}

#  else // _LIBCPP_STD_VER >= 20

template <class... _Tp, class... _Up>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool
operator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
  return !(__x == __y);
}

template <size_t _Ip>
struct __tuple_less {
  template <class _Tp, class _Up>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool operator()(const _Tp& __x, const _Up& __y) {
    const size_t __idx = tuple_size<_Tp>::value - _Ip;
    if (std::get<__idx>(__x) < std::get<__idx>(__y))
      return true;
    if (std::get<__idx>(__y) < std::get<__idx>(__x))
      return false;
    return __tuple_less<_Ip - 1>()(__x, __y);
  }
};

template <>
struct __tuple_less<0> {
  template <class _Tp, class _Up>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool operator()(const _Tp&, const _Up&) {
    return false;
  }
};

template <class... _Tp, class... _Up>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool
operator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
  static_assert(sizeof...(_Tp) == sizeof...(_Up), "Can't compare tuples of different sizes");
  return __tuple_less<sizeof...(_Tp)>()(__x, __y);
}

template <class... _Tp, class... _Up>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool
operator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
  return __y < __x;
}

template <class... _Tp, class... _Up>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool
operator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
  return !(__x < __y);
}

template <class... _Tp, class... _Up>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool
operator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
  return !(__y < __x);
}

#  endif // _LIBCPP_STD_VER >= 20

// tuple_cat

template <class _Tp, class _Up>
struct __tuple_cat_type;

template <class... _Ttypes, class... _Utypes>
struct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> > {
  typedef _LIBCPP_NODEBUG tuple<_Ttypes..., _Utypes...> type;
};

template <class _ResultTuple, bool _Is_Tuple0TupleLike, class... _Tuples>
struct __tuple_cat_return_1 {};

template <class... _Types, class _Tuple0>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0> {
  using type _LIBCPP_NODEBUG =
      typename __tuple_cat_type< tuple<_Types...>,
                                 typename __make_tuple_types<__remove_cvref_t<_Tuple0> >::type >::type;
};

template <class... _Types, class _Tuple0, class _Tuple1, class... _Tuples>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_1<
          typename __tuple_cat_type< tuple<_Types...>,
                                     typename __make_tuple_types<__remove_cvref_t<_Tuple0> >::type >::type,
          __tuple_like_ext<__libcpp_remove_reference_t<_Tuple1> >::value,
          _Tuple1,
          _Tuples...> {};

template <class... _Tuples>
struct __tuple_cat_return;

template <class _Tuple0, class... _Tuples>
struct __tuple_cat_return<_Tuple0, _Tuples...>
    : public __tuple_cat_return_1<tuple<>,
                                  __tuple_like_ext<__libcpp_remove_reference_t<_Tuple0> >::value,
                                  _Tuple0,
                                  _Tuples...> {};

template <>
struct __tuple_cat_return<> {
  typedef _LIBCPP_NODEBUG tuple<> type;
};

inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 tuple<> tuple_cat() { return tuple<>(); }

template <class _Rp, class _Indices, class _Tuple0, class... _Tuples>
struct __tuple_cat_return_ref_imp;

template <class... _Types, size_t... _I0, class _Tuple0>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0> {
  typedef _LIBCPP_NODEBUG __libcpp_remove_reference_t<_Tuple0> _T0;
  typedef tuple<_Types..., __apply_cv_t<_Tuple0, typename tuple_element<_I0, _T0>::type>&&...> type;
};

template <class... _Types, size_t... _I0, class _Tuple0, class _Tuple1, class... _Tuples>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_ref_imp<
          tuple<_Types...,
                __apply_cv_t<_Tuple0, typename tuple_element<_I0, __libcpp_remove_reference_t<_Tuple0>>::type>&&...>,
          typename __make_tuple_indices<tuple_size<__libcpp_remove_reference_t<_Tuple1> >::value>::type,
          _Tuple1,
          _Tuples...> {};

template <class _Tuple0, class... _Tuples>
struct __tuple_cat_return_ref
    : public __tuple_cat_return_ref_imp<
          tuple<>,
          typename __make_tuple_indices< tuple_size<__libcpp_remove_reference_t<_Tuple0> >::value >::type,
          _Tuple0,
          _Tuples...> {};

template <class _Types, class _I0, class _J0>
struct __tuple_cat;

template <class... _Types, size_t... _I0, size_t... _J0>
struct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> > {
  template <class _Tuple0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14
      typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type
      operator()(tuple<_Types...> __t, _Tuple0&& __t0) {
    (void)__t; // avoid unused parameter warning on GCC when _I0 is empty
    return std::forward_as_tuple(
        std::forward<_Types>(std::get<_I0>(__t))..., std::get<_J0>(std::forward<_Tuple0>(__t0))...);
  }

  template <class _Tuple0, class _Tuple1, class... _Tuples>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14
      typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type
      operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&&... __tpls) {
    (void)__t; // avoid unused parameter warning on GCC when _I0 is empty
    typedef _LIBCPP_NODEBUG __libcpp_remove_reference_t<_Tuple0> _T0;
    typedef _LIBCPP_NODEBUG __libcpp_remove_reference_t<_Tuple1> _T1;
    return __tuple_cat<tuple<_Types..., __apply_cv_t<_Tuple0, typename tuple_element<_J0, _T0>::type>&&...>,
                       typename __make_tuple_indices<sizeof...(_Types) + tuple_size<_T0>::value>::type,
                       typename __make_tuple_indices<tuple_size<_T1>::value>::type>()(
        std::forward_as_tuple(
            std::forward<_Types>(std::get<_I0>(__t))..., std::get<_J0>(std::forward<_Tuple0>(__t0))...),
        std::forward<_Tuple1>(__t1),
        std::forward<_Tuples>(__tpls)...);
  }
};

template <class _Tuple0, class... _Tuples>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 typename __tuple_cat_return<_Tuple0, _Tuples...>::type
tuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls) {
  typedef _LIBCPP_NODEBUG __libcpp_remove_reference_t<_Tuple0> _T0;
  return __tuple_cat<tuple<>, __tuple_indices<>, typename __make_tuple_indices<tuple_size<_T0>::value>::type>()(
      tuple<>(), std::forward<_Tuple0>(__t0), std::forward<_Tuples>(__tpls)...);
}

template <class... _Tp, class _Alloc>
struct _LIBCPP_TEMPLATE_VIS uses_allocator<tuple<_Tp...>, _Alloc> : true_type {};

template <class _T1, class _T2>
template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 pair<_T1, _T2>::pair(
    piecewise_construct_t,
    tuple<_Args1...>& __first_args,
    tuple<_Args2...>& __second_args,
    __tuple_indices<_I1...>,
    __tuple_indices<_I2...>)
    : first(std::forward<_Args1>(std::get<_I1>(__first_args))...),
      second(std::forward<_Args2>(std::get<_I2>(__second_args))...) {}

#    if _LIBCPP_STD_VER >= 17
template <class _Tp>
inline constexpr size_t tuple_size_v = tuple_size<_Tp>::value;

#      define _LIBCPP_NOEXCEPT_RETURN(...)                                                                             \
        noexcept(noexcept(__VA_ARGS__)) { return __VA_ARGS__; }

// The _LIBCPP_NOEXCEPT_RETURN macro breaks formatting.
// clang-format off
template <class _Fn, class _Tuple, size_t... _Id>
inline _LIBCPP_HIDE_FROM_ABI constexpr decltype(auto)
__apply_tuple_impl(_Fn&& __f, _Tuple&& __t, __tuple_indices<_Id...>)
    _LIBCPP_NOEXCEPT_RETURN(std::__invoke(std::forward<_Fn>(__f), std::get<_Id>(std::forward<_Tuple>(__t))...))

template <class _Fn, class _Tuple>
inline _LIBCPP_HIDE_FROM_ABI constexpr decltype(auto) apply(_Fn&& __f, _Tuple&& __t)
    _LIBCPP_NOEXCEPT_RETURN(std::__apply_tuple_impl(
        std::forward<_Fn>(__f),
        std::forward<_Tuple>(__t),
        typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}))

template <class _Tp, class _Tuple, size_t... _Idx>
inline _LIBCPP_HIDE_FROM_ABI constexpr _Tp __make_from_tuple_impl(_Tuple&& __t, __tuple_indices<_Idx...>)
    _LIBCPP_NOEXCEPT_RETURN(_Tp(std::get<_Idx>(std::forward<_Tuple>(__t))...))

template <class _Tp, class _Tuple>
inline _LIBCPP_HIDE_FROM_ABI constexpr _Tp make_from_tuple(_Tuple&& __t)
    _LIBCPP_NOEXCEPT_RETURN(std::__make_from_tuple_impl<_Tp>(
        std::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}))

#    undef _LIBCPP_NOEXCEPT_RETURN

#  endif // _LIBCPP_STD_VER >= 17

#endif // !defined(_LIBCPP_CXX03_LANG)
#else
#pragma GCC diagnostic ignored "-Wc++26-extensions"
template<class T, class U>
concept __synth_three_way_comparable_with = requires(T const& t, U const& u) {
    { t < u } -> std::__boolean_testable;
    { u < t } -> std::__boolean_testable;
};

template<class T, class Alloc, class... Ts>
concept __uses_allocator_construction =
  uses_allocator_v<T, Alloc> and
  (is_constructible_v<T, allocator_arg_t, Alloc, Ts...> or is_constructible_v<T, Ts..., Alloc>);

template<class T, class Alloc, class... Ts>
concept __constructible_with_allocator =
  __uses_allocator_construction<T, Alloc, Ts...> or is_constructible_v<T, Ts...>;

template<class T, class Alloc, class... Ts>
requires __constructible_with_allocator<T, Alloc, Ts...>
T __construct_with_allocator(Alloc const& __alloc, Ts&&... ts)
{
  if constexpr (not uses_allocator_v<T, Alloc>) {
    return T(std::forward<Ts>(ts)...);
  }
  else if constexpr (is_constructible_v<T, allocator_arg_t, Alloc, Ts...>) {
    return T(allocator_arg, __alloc, std::forward<Ts>(ts)...);
  }
  else {
    return T(std::forward<Ts>(ts)..., __alloc);
  }
}

template<class... Ts>
class _LIBCPP_TEMPLATE_VIS tuple;

template<>
class _LIBCPP_TEMPLATE_VIS tuple<> {
public:
  [[clang::always_inline]] tuple() = default;
  [[clang::always_inline]] tuple(tuple const&) = default;
  [[clang::always_inline]] tuple(tuple&&) = default;

  [[clang::always_inline]] tuple(allocator_arg_t, auto const&) noexcept {}
  [[clang::always_inline]] tuple(allocator_arg_t, auto const&, tuple const&) noexcept {}
  [[clang::always_inline]] tuple(allocator_arg_t, auto const&, tuple&&) noexcept {}

  [[clang::always_inline]] constexpr void swap(tuple&) noexcept {}
  [[clang::always_inline]] constexpr void swap(tuple const&) const noexcept {}

  friend constexpr auto operator<=>(tuple, tuple) = default;
};

template<class... UTypes>
tuple(UTypes...) -> tuple<UTypes...>;
template<class T1, class T2>
tuple(std::pair<T1, T2>) -> tuple<T1, T2>;
template<class Alloc, class... UTypes>
tuple(allocator_arg_t, Alloc, UTypes...) -> tuple<UTypes...>;
template<class Alloc, class T1, class T2>
tuple(allocator_arg_t, Alloc, std::pair<T1, T2>) -> tuple<T1, T2>;
template<class Alloc, class... UTypes>
tuple(allocator_arg_t, Alloc, tuple<UTypes...>) -> tuple<UTypes...>;

template<class T>
void __implicitly_construct(T);

template<class T, class... Args>
inline constexpr bool __is_implicitly_constructible = requires(Args&&... args) {
  __implicitly_construct<T>({std::forward<Args>(args)...});
};

template<class T0>
class _LIBCPP_TEMPLATE_VIS tuple<T0> {
public:
  [[no_unique_address]] T0 __x0;

  constexpr explicit(not (__is_implicitly_constructible<T0>)) tuple() noexcept(is_nothrow_default_constructible_v<T0>) requires std::is_default_constructible_v<T0>
  : __x0()
  {}

  constexpr explicit(not (is_convertible_v<T0 const&, T0>)) tuple(T0 const& t) noexcept(is_nothrow_copy_constructible_v<T0>)
  requires requires { T0{t}; }
  : __x0(t)
  {}

  template<class U0>
  requires is_constructible_v<T0, U0> and (not (std::is_same_v<std::remove_cvref_t<U0>, tuple> /* or reference_constructs_from_temporary_v<T0, U0&&*/))
  constexpr explicit(not is_convertible_v<U0, T0>) tuple(U0&& u0) noexcept(is_nothrow_constructible_v<T0, U0>)
  : __x0(std::forward<U0>(u0))
  {}

  template<class U0>
  requires (not (is_convertible_v<tuple<U0>&, T0> or is_constructible_v<T0, tuple<U0>&> or std::same_as<T0, U0>))
  constexpr explicit(not is_convertible_v<U0&, T0>) tuple(tuple<U0>& t) noexcept(is_nothrow_constructible_v<T0, tuple<U0>&>)
  : __x0(std::forward<U0>(t.__x0))
  {}

  template<class U0>
  requires (not (is_convertible_v<tuple<U0> const&, T0> or is_constructible_v<T0, tuple<U0> const&> or std::same_as<T0, U0>))
  constexpr explicit(not is_convertible_v<U0 const&, T0>) tuple(tuple<U0> const& t) noexcept(is_nothrow_constructible_v<T0, tuple<U0> const&>)
  : __x0(std::forward<U0 const>(t.__x0))
  {}

  template<class U0>
  requires (not (is_convertible_v<tuple<U0>&&, T0> or is_constructible_v<T0, tuple<U0>&&> or std::same_as<T0, U0>))
  constexpr explicit(not is_convertible_v<U0&&, T0>) tuple(tuple<U0>&& t) noexcept(is_nothrow_constructible_v<T0, tuple<U0>&&>)
  : __x0(std::forward<U0>(t.__x0))
  {}

  template<class U0>
  requires (not (is_convertible_v<tuple<U0> const&&, T0> or is_constructible_v<T0, tuple<U0> const&&> or std::same_as<T0, U0>))
  constexpr explicit(not is_convertible_v<U0 const&&, T0>) tuple(tuple<U0> const&& t) noexcept(is_nothrow_constructible_v<T0, tuple<U0> const&&>)
  : __x0(std::forward<U0 const>(t.__x0))
  {}

  template<class _U0>
  requires (not (is_convertible_v<std::array<_U0, 1>, _U0> or is_constructible_v<_U0, std::array<_U0, 1>>))
  constexpr explicit(not (is_convertible_v<_U0, T0>)) tuple(std::array<_U0, 1>& __a) noexcept(is_nothrow_constructible_v<T0, array<_U0, 1>&>)
  : __x0(__a[0])
  {}

  template<class _U0>
  requires (not (is_convertible_v<std::array<_U0, 1>, _U0> or is_constructible_v<_U0, std::array<_U0, 1>>))
  constexpr explicit(not (is_convertible_v<_U0, T0>)) tuple(std::array<_U0, 1> const& __a) noexcept(is_nothrow_constructible_v<T0, array<_U0, 1> const&>)
  : __x0(__a[0])
  {}

  template<class _U0>
  requires (not (is_convertible_v<std::array<_U0, 1>, _U0> or is_constructible_v<_U0, std::array<_U0, 1>>))
  constexpr explicit(not (is_convertible_v<_U0, T0>)) tuple(std::array<_U0, 1>&& __a) noexcept(is_nothrow_constructible_v<T0, array<_U0, 1>&&>)
  : __x0(std::move(__a[0]))
  {}

  template<class _U0>
  requires (not (is_convertible_v<std::array<_U0, 1>, _U0> or is_constructible_v<_U0, std::array<_U0, 1>>))
  constexpr explicit(not (is_convertible_v<_U0, T0>)) tuple(std::array<_U0, 1> const&& __a) noexcept(is_nothrow_constructible_v<T0, array<_U0, 1> const&&>)
  : __x0(std::move(__a[0]))
  {}

  template<class Alloc>
  requires __constructible_with_allocator<T0, Alloc const&>
  constexpr explicit(not __is_implicitly_constructible<T0, Alloc const&>) tuple(allocator_arg_t, Alloc const& __a)
  : __x0(__construct_with_allocator<T0>(__a))
  {}

  template<class Alloc>
  requires __constructible_with_allocator<T0, Alloc const&, T0 const&>
  constexpr explicit(not __is_implicitly_constructible<T0, Alloc const&, T0 const>)
  tuple(allocator_arg_t, Alloc const& a, T0 const& t)
  : __x0(__construct_with_allocator<T0>(a, t))
  {}

  template<class Alloc, class U0>
  requires __constructible_with_allocator<T0, Alloc const&, U0&&> and (not (std::is_same_v<std::remove_cvref_t<U0>, tuple> /* or reference_constructs_from_temporary_v<T0, U0&&*/))
  constexpr explicit(not __is_implicitly_constructible<T0, Alloc const&, U0&&>)
  tuple(allocator_arg_t, Alloc const& a, U0&& u)
  : __x0(__construct_with_allocator<T0>(a, std::forward<U0>(u)))
  {}

  template<class Alloc>
  requires __constructible_with_allocator<T0, Alloc const&, T0 const&>
  constexpr explicit(not __is_implicitly_constructible<T0, Alloc const&, T0 const&>)
  tuple(allocator_arg_t, Alloc const& a, tuple const& other)
  : __x0(__construct_with_allocator<T0>(a, other.__x0))
  {}

  template<class Alloc>
  requires __constructible_with_allocator<T0, Alloc const&, T0&&>
  constexpr explicit(not __is_implicitly_constructible<T0, Alloc const&, T0&&>)
  tuple(allocator_arg_t, Alloc const& a, tuple&& other)
  : __x0(__construct_with_allocator<T0>(a, std::move(other.__x0)))
  {}

  template<class Alloc, class U0>
  requires __constructible_with_allocator<T0, Alloc const&, U0&>
  constexpr explicit(not (is_convertible_v<U0&, T0>)) tuple(allocator_arg_t, Alloc const& a, tuple<U0>& u)
  : __x0(__construct_with_allocator<T0>(a, u.__x0))
  {}

  template<class Alloc, class U0>
  requires __constructible_with_allocator<T0, Alloc const&, U0 const&>
  constexpr explicit(not (is_convertible_v<U0 const&, T0>)) tuple(allocator_arg_t, Alloc const& a, tuple<U0> const& u)
  : __x0(__construct_with_allocator<T0>(a, u.__x0))
  {}

  template<class Alloc, class U0>
  requires __constructible_with_allocator<T0, Alloc const&, U0&&>
  constexpr explicit(not (is_convertible_v<U0&&, T0>)) tuple(allocator_arg_t, Alloc const& a, tuple<U0>&& u)
  : __x0(__construct_with_allocator<T0>(a, std::move(u.__x0)))
  {}

  template<class Alloc, class U0>
  requires __constructible_with_allocator<T0, Alloc const&, U0 const&&>
  constexpr explicit(not (is_convertible_v<U0 const&&, T0>)) tuple(allocator_arg_t, Alloc const& a, tuple<U0> const&& u)
  : __x0(__construct_with_allocator<T0>(a, std::move(u.__x0)))
  {}

  // template<class Alloc, tuple-like UTuple>
  // constexpr explicit(see below) tuple(allocator_arg_t, const Alloc& a, UTuple&&);

  tuple(tuple const&) = default;
  tuple(tuple&&) = default;

  // [tuple.assign], tuple assignment
  constexpr tuple& operator=(tuple const& other) = default;
  constexpr tuple& operator=(tuple&&) = default;

  constexpr const tuple& operator=(tuple const& other) const
  requires std::is_copy_assignable_v<T0 const>
  {
    [[clang::always_inline]] __x0 = other.__x0;
    return *this;
  }

  constexpr const tuple& operator=(tuple&& other) const
  requires std::is_assignable_v<T0 const&, T0>
  {
    [[clang::always_inline]] __x0 = std::forward<T0>(other.__x0);
    return *this;
  }

  template<class U0>
  constexpr tuple& operator=(tuple<U0> const& other)
  requires std::is_assignable_v<T0&, U0 const&>
  {
    [[clang::always_inline]] __x0 = other.__x0;
    return *this;
  }

  template<class U0>
  constexpr tuple const& operator=(tuple<U0> const& other) const
  requires std::is_assignable_v<T0 const&, U0 const&>
  {
    [[clang::always_inline]] __x0 = other.__x0;
    return *this;
  }

  template<class U0>
  constexpr tuple& operator=(tuple<U0>&& other)
  requires std::is_assignable_v<T0&, U0>
  {
    [[clang::always_inline]] __x0 = std::move(other.__x0);
    return *this;
  }

  template<class U0>
  constexpr tuple const& operator=(tuple<U0> const&& other) const
  requires std::is_assignable_v<T0 const&, U0 const>
  {
    [[clang::always_inline]] __x0 = std::move(other.__x0);
    return *this;
  }

  // [tuple.swap], tuple swap
  constexpr void swap(tuple& other) noexcept(std::is_nothrow_swappable_v<T0>)
  requires std::swappable<T0>
  {
    [[clang::always_inline]] std::ranges::swap(__x0, other.__x0);
  }

  constexpr void swap(tuple const& other) const noexcept(std::is_nothrow_swappable_v<T0 const>)
  requires std::swappable<T0 const>
  {
    [[clang::always_inline]] std::ranges::swap(__x0, other.__x0);
  }

  template<std::equality_comparable_with<T0> U0>
  friend constexpr bool operator==(tuple const& t, tuple<U0> const& u)
  {
    return t.__x0 == u.__x0;
  }

  template<__synth_three_way_comparable_with<T0> U0>
  friend constexpr auto operator<=>(tuple const& t, tuple<U0> const& u)
    -> common_comparison_category_t<__synth_three_way_result<T0, U0>>
  {
    return __synth_three_way(t.__x0, u.__x0);
  }
};

template<class T0, class T1>
class _LIBCPP_TEMPLATE_VIS tuple<T0, T1> {
public:
  [[no_unique_address]] T0 __x0;
  [[no_unique_address]] T1 __x1;

  constexpr explicit(not (__is_implicitly_constructible<T0> and
                          __is_implicitly_constructible<T1>))
  tuple() noexcept(is_nothrow_default_constructible_v<T0> and is_nothrow_default_constructible_v<T1>)
  requires std::is_default_constructible_v<T0> and
           std::is_default_constructible_v<T1>
  : __x0()
  , __x1()
  {}

  constexpr explicit(not (is_convertible_v<T0 const&, T0> and is_convertible_v<T1 const&, T1>))
  tuple(T0 const& t0, T1 const& t1) noexcept(is_nothrow_copy_constructible_v<T0> and is_nothrow_copy_constructible_v<T1>)
  requires std::is_copy_constructible_v<T0>
  : __x0(t0)
  , __x1(t1)
  {}

  template<class U0, class U1>
  requires is_constructible_v<T0, U0> and
            is_constructible_v<T1, U1> and
            (not std::same_as<std::remove_cvref_t<U0>, allocator_arg_t> or std::same_as<std::remove_cvref_t<T0>, allocator_arg_t>)
  constexpr explicit(not (is_convertible_v<U0, T0> and is_convertible_v<U1, T1>)) tuple(U0&& u0, U1&& u1)
    noexcept(is_nothrow_constructible_v<T0, U0> and is_nothrow_constructible_v<T1, U1>)
  : __x0(std::forward<U0>(u0))
  , __x1(std::forward<U1>(u1))
  {}

  template<class U0, class U1>
  requires is_constructible_v<T0, U0&> and
            is_constructible_v<T1, U1&>
  constexpr explicit(not (is_convertible_v<U0&, T0> and is_convertible_v<U1&, T1>)) tuple(tuple<U0, U1>& t)
  : __x0(std::forward<U0>(t.__x0))
  , __x1(std::forward<U1>(t.__x1))
  {}

  template<class U0, class U1>
  requires is_constructible_v<T0, U0 const&> and
            is_constructible_v<T1, U1 const&>
  constexpr explicit(not (is_convertible_v<U0 const&, T0> and is_convertible_v<U1 const&, T1>))
  tuple(tuple<U0, U1> const& t)
  : __x0(std::forward<U0 const>(t.__x0))
  , __x1(std::forward<U1 const>(t.__x1))
  {}

  template<class U0, class U1>
  requires is_constructible_v<T0, U0&&> and
            is_constructible_v<T1, U1&&>
  constexpr explicit(not (is_convertible_v<U0&&, T0> and is_convertible_v<U1&&, T1>))
  tuple(tuple<U0, U1>&& t)
  : __x0(std::forward<U0>(t.__x0))
  , __x1(std::forward<U1>(t.__x1))
  {}

  template<class U0, class U1>
  requires is_constructible_v<T0, U0 const> and
           is_constructible_v<T1, U1 const>
  constexpr explicit(not (is_convertible_v<U0, T0> and is_convertible_v<U1, T1>))
  tuple(tuple<U0, U1> const&& t)
  : __x0(std::forward<U0 const>(t.__x0))
  , __x1(std::forward<U1 const>(t.__x1))
  {}

  template<class U0, class U1>
  requires is_constructible_v<T0, U0&> and is_constructible_v<T1, U1&>
  constexpr explicit(not (is_convertible_v<U0&, T0> and is_convertible_v<U1&, T1>)) tuple(std::pair<U0, U1>& other)         // only if sizeof...(Types) == 2
  : __x0(other.first)
  , __x1(other.second)
  {}

  template<class U0, class U1>
  requires is_constructible_v<T0, U0 const&> and is_constructible_v<T1, U1 const&>
  constexpr explicit(not (is_convertible_v<U0 const&, T0> and is_convertible_v<U1 const&, T1>)) tuple(std::pair<U0, U1> const& other)   // only if sizeof...(Types) == 2
  : __x0(other.first)
  , __x1(other.second)
  {}

  template<class U0, class U1>
  requires is_constructible_v<T0, U0> and is_constructible_v<T1, U1>
  constexpr explicit(not (is_convertible_v<U0&&, T0> and is_convertible_v<U1&&, T1>)) tuple(std::pair<U0, U1>&& other)        // only if sizeof...(Types) == 2
  : __x0(std::move(other.first))
  , __x1(std::move(other.second))
  {}

  template<class U0, class U1>
  requires is_constructible_v<T0, U0 const> and is_constructible_v<T1, U1 const>
  constexpr explicit(not (is_convertible_v<U0 const&&, T0> and is_convertible_v<U1 const&&, T1>)) tuple(std::pair<U0, U1> const&& other)  // only if sizeof...(Types) == 2
  : __x0(std::move(other.first))
  , __x1(std::move(other.second))
  {}

  // template<tuple-like UTuple>
  //     constexpr explicit(see below) tuple(UTuple&&);

  template<class Alloc>
  requires __constructible_with_allocator<T0, Alloc const&> and
           __constructible_with_allocator<T1, Alloc const&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&> and __is_implicitly_constructible<T1, Alloc const&>))
  tuple(allocator_arg_t, Alloc const& a)
  : __x0(a)
  , __x1(a)
  {}

  template<class Alloc>
  requires __constructible_with_allocator<T0, Alloc const&, T0 const&> and
           __constructible_with_allocator<T1, Alloc const&, T1 const&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, T0 const&> and
                          __is_implicitly_constructible<T1, Alloc const&, T1 const&>))
  tuple(allocator_arg_t, Alloc const& a, T0 const& t0, T1 const& t1)
  : __x0(__construct_with_allocator<T0>(a, t0))
  , __x1(__construct_with_allocator<T1>(a, t1))
  {}

  template<class Alloc, class U0, class U1>
  requires __constructible_with_allocator<T0, Alloc const&, U0&&> and
           __constructible_with_allocator<T1, Alloc const&, U1&&> and
            (not std::is_same_v<std::remove_cvref_t<U0>, allocator_arg_t> or
             std::is_same_v<std::remove_cvref_t<T0>, allocator_arg_t>)
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0> and
                          __is_implicitly_constructible<T1, Alloc const&, U1>))
  tuple(allocator_arg_t, Alloc const& a, U0&& u0, U1&& u1)
  : __x0(__construct_with_allocator<T0>(a, std::forward<U0>(u0)))
  , __x1(__construct_with_allocator<T1>(a, std::forward<U0>(u1)))
  {}

  template<class Alloc>
  requires __constructible_with_allocator<T0, Alloc const&, T0 const&> and
           __constructible_with_allocator<T1, Alloc const&, T1 const&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, T0 const&> and
                          __is_implicitly_constructible<T1, Alloc const&, T1 const&>))
  tuple(allocator_arg_t, Alloc const& a, tuple const& other)
  : __x0(__construct_with_allocator<T0>(a, other.__x0))
  , __x1(__construct_with_allocator<T1>(a, other.__x1))
  {}

  template<class Alloc>
  requires __constructible_with_allocator<T0, Alloc const&, T0&&> and
           __constructible_with_allocator<T1, Alloc const&, T1&&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, T0&&> and
                          __is_implicitly_constructible<T1, Alloc const&, T1&&>))
  tuple(allocator_arg_t, Alloc const& a, tuple&& other)
  : __x0(__construct_with_allocator<T0>(a, std::move(other.__x0)))
  , __x1(__construct_with_allocator<T1>(a, std::move(other.__x1)))
  {}

  template<class Alloc, class U0, class U1>
  requires __constructible_with_allocator<T0, Alloc const&, U0&> and
           __constructible_with_allocator<T1, Alloc const&, U1&>
  constexpr explicit(not (is_convertible_v<U0&, T0> and
                          is_convertible_v<U1&, T1>))
  tuple(allocator_arg_t, Alloc const& a, tuple<U0, U1>& u)
  : __x0(__construct_with_allocator<T0>(a, u.__x0))
  , __x1(__construct_with_allocator<T1>(a, u.__x1))
  {}

  template<class Alloc, class U0, class U1>
  requires __constructible_with_allocator<T0, Alloc const&, U0 const&> and
           __constructible_with_allocator<T1, Alloc const&, U1 const&>
  constexpr explicit(not (is_convertible_v<U0 const&, T0> and
                          is_convertible_v<U1 const&, T1>))
  tuple(allocator_arg_t, Alloc const& a, tuple<U0, U1> const& u)
  : __x0(__construct_with_allocator<T0>(a, u.__x0))
  , __x1(__construct_with_allocator<T1>(a, u.__x1))
  {}

  template<class Alloc, class U0, class U1>
  requires __constructible_with_allocator<T0, Alloc const&, U0&&> and
           __constructible_with_allocator<T1, Alloc const&, U1&&>
  constexpr explicit(not (is_convertible_v<U0&&, T0> and
                          is_convertible_v<U1&&, T1>))
  tuple(allocator_arg_t, Alloc const& a, tuple<U0, U1>&& u)
  : __x0(__construct_with_allocator<T0>(a, std::move(u.__x0)))
  , __x1(__construct_with_allocator<T1>(a, std::move(u.__x1)))
  {}

  template<class Alloc, class U0, class U1>
  requires __constructible_with_allocator<T0, Alloc const&, U0 const&&> and
           __constructible_with_allocator<T1, Alloc const&, U1 const&&>
  constexpr explicit(not (is_convertible_v<U0 const&&, T0> and
                          is_convertible_v<U1 const&&, T1>))
  tuple(allocator_arg_t, Alloc const& a, tuple<U0, U1> const&& u)
  : __x0(__construct_with_allocator<T0>(a, std::move(u.__x0)))
  , __x1(__construct_with_allocator<T1>(a, std::move(u.__x1)))
  {}

  template<class Alloc, class U0, class U1>
  requires __constructible_with_allocator<T0, Alloc const&, U0&> and
           __constructible_with_allocator<T1, Alloc const&, U1&>
  constexpr explicit(not (is_convertible_v<U0&, T0> and
                          is_convertible_v<U1&, T1>))
  tuple(allocator_arg_t, const Alloc& a, std::pair<U0, U1>& other)
  : __x0(__construct_with_allocator<T0>(a, other.first))
  , __x1(__construct_with_allocator<T1>(a, other.second))
  {}

  template<class Alloc, class U0, class U1>
  requires __constructible_with_allocator<T0, Alloc const&, U0 const&> and
           __constructible_with_allocator<T1, Alloc const&, U1 const&>
  constexpr explicit(not (is_convertible_v<U0 const&, T0> and
                          is_convertible_v<U1 const&, T1>))
  tuple(allocator_arg_t, const Alloc& a, std::pair<U0, U1> const& other)
  : __x0(__construct_with_allocator<T0>(a, other.first))
  , __x1(__construct_with_allocator<T1>(a, other.second))
  {}

  template<class Alloc, class U0, class U1>
  requires __constructible_with_allocator<T0, Alloc const&, U0> and
           __constructible_with_allocator<T1, Alloc const&, U1>
  constexpr explicit(not (is_convertible_v<U0, T0> and
                          is_convertible_v<U1, T1>))
  tuple(allocator_arg_t, const Alloc& a, std::pair<U0, U1>&& other)
  : __x0(__construct_with_allocator<T0>(a, std::move(other.first)))
  , __x1(__construct_with_allocator<T1>(a, std::move(other.second)))
  {}

  template<class Alloc, class U0, class U1>
  requires __constructible_with_allocator<T0, Alloc const&, U0 const> and
           __constructible_with_allocator<T1, Alloc const&, U1 const>
  constexpr explicit(not (is_convertible_v<U0 const, T0> and
                          is_convertible_v<U1 const, T1>))
  tuple(allocator_arg_t, const Alloc& a, std::pair<U0, U1> const&& other)
  : __x0(__construct_with_allocator<T0>(a, std::move(other.first)))
  , __x1(__construct_with_allocator<T1>(a, std::move(other.second)))
  {}

  // template<class Alloc, tuple-like UTuple>
  // constexpr explicit(see below) tuple(allocator_arg_t, const Alloc& a, UTuple&&);

  tuple(tuple const&) = default;
  tuple(tuple&&) = default;

  // [tuple.assign], tuple assignment
  constexpr tuple& operator=(tuple const&) = default;
  constexpr tuple& operator=(tuple&&) = default;

  constexpr const tuple& operator=(tuple const& other) const
  requires std::is_copy_assignable_v<T0 const> and
           std::is_copy_assignable_v<T1 const>
  {
    [[clang::always_inline]] __x0 = other.__x0;
    [[clang::always_inline]] __x1 = other.__x1;
    return *this;
  }

  constexpr const tuple& operator=(tuple&& other) const
  requires std::is_assignable_v<T0 const&, T0> and
           std::is_assignable_v<T1 const&, T1>
  {
    [[clang::always_inline]] swap(std::move(other));
    return *this;
  }

  template<class U0, class U1>
  requires std::is_assignable_v<T0&, U0 const&> and
           std::is_assignable_v<T1&, U1 const&>
  constexpr tuple& operator=(tuple<U0, U1> const& other)
  {
    [[clang::always_inline]] __x0 = other.__x0;
    [[clang::always_inline]] __x1 = other.__x1;
    return *this;
  }

  template<class U0, class U1>
  requires std::is_assignable_v<T0 const&, U0 const&> and
           std::is_assignable_v<T1 const&, U1 const&>
  constexpr tuple const& operator=(tuple<U0, U1> const& other) const
  {
    [[clang::always_inline]] __x0 = other.__x0;
    [[clang::always_inline]] __x1 = other.__x1;
    return *this;
  }

  template<class U0, class U1>
  requires std::is_assignable_v<T0&, U0> and
           std::is_assignable_v<T1&, U1>
  constexpr tuple& operator=(tuple<U0, U1>&& other)
  {
    [[clang::always_inline]] __x0 = std::move(other.__x0);
    [[clang::always_inline]] __x1 = std::move(other.__x1);
    return *this;
  }

  template<class U0, class U1>
  requires std::is_assignable_v<T0 const&, U0 const> and
           std::is_assignable_v<T1 const&, U1 const>
  constexpr tuple const& operator=(tuple<U0, U1> const&& other) const
  {
    [[clang::always_inline]] __x0 = std::move(other.__x0);
    [[clang::always_inline]] __x1 = std::move(other.__x1);
    return *this;
  }

  template<class U0, class U1>
  requires std::is_assignable_v<T0&, U0 const&> and
           std::is_assignable_v<T1&, U1 const&>
  constexpr tuple& operator=(std::pair<U0, U1> const& other)
  {
    [[clang::always_inline]] __x0 = other.first;
    [[clang::always_inline]] __x1 = other.second;
    return *this;
  }

  template<class U0, class U1>
  requires std::is_assignable_v<T0 const&, U0 const&> and
           std::is_assignable_v<T1 const&, U1 const&>
  constexpr tuple const& operator=(std::pair<U0, U1> const& other) const
  {
    [[clang::always_inline]] __x0 = other.first;
    [[clang::always_inline]] __x1 = other.second;
    return *this;
  }

  template<class U0, class U1>
  requires std::is_assignable_v<T0&, U0> and
           std::is_assignable_v<T1&, U1>
  constexpr tuple& operator=(std::pair<U0, U1>&& other)
  {
    [[clang::always_inline]] __x0 = std::move(other.first);
    [[clang::always_inline]] __x1 = std::move(other.second);
    return *this;
  }

  template<class U0, class U1>
  requires std::is_assignable_v<T0 const&, U0 const> and
           std::is_assignable_v<T1 const&, U1 const>
  constexpr tuple const& operator=(std::pair<U0, U1> const&& other) const
  {
    [[clang::always_inline]] __x0 = std::move(other.first);
    [[clang::always_inline]] __x1 = std::move(other.second);
    return *this;
  }

  // template<tuple-like UTuple>
  // constexpr tuple& operator=(UTuple&&);
  // template<tuple-like UTuple>
  // constexpr const tuple& operator=(UTuple&&) const;

  // [tuple.swap], tuple swap

  constexpr void swap(tuple& other) noexcept(std::is_nothrow_swappable_v<T0> and
                                             std::is_nothrow_swappable_v<T1>)
  requires std::swappable<T0> and
           std::swappable<T1>
  {
    [[clang::always_inline]] std::ranges::swap(__x0, other.__x0);
    [[clang::always_inline]] std::ranges::swap(__x1, other.__x1);
  }

  constexpr void swap(tuple const& other) const noexcept(std::is_nothrow_swappable_v<T0 const> and
                                                         std::is_nothrow_swappable_v<T1 const>)
  requires std::swappable<T0 const> and
           std::swappable<T1 const>
  {
    [[clang::always_inline]] std::ranges::swap(__x0, other.__x0);
    [[clang::always_inline]] std::ranges::swap(__x1, other.__x1);
  }

  template<std::equality_comparable_with<T0> U0,
           std::equality_comparable_with<T1> U1>
  friend constexpr bool operator==(tuple const& t, tuple<U0, U1> const& u)
  {
      return t.__x0 == u.__x0 and
          t.__x1 == u.__x1;
  }

  template<__synth_three_way_comparable_with<T0> U0,
           __synth_three_way_comparable_with<T1> U1>
  friend constexpr auto operator<=>(tuple const& t, tuple<U0, U1> const& u)
    -> common_comparison_category_t<__synth_three_way_result<T0, U0>,
                                    __synth_three_way_result<T1, U1>>
  {
    if (auto result = __synth_three_way(t.__x0, u.__x0); result != std::partial_ordering::equivalent) {
      return result;
    }

    return __synth_three_way(t.__x1, u.__x1);
  }
};

template<class T0, class T1, class T2>
class _LIBCPP_TEMPLATE_VIS tuple<T0, T1, T2> {
public:
  [[no_unique_address]] T0 __x0;
  [[no_unique_address]] T1 __x1;
  [[no_unique_address]] T2 __x2;

  constexpr explicit(not (__is_implicitly_constructible<T0> and
                          __is_implicitly_constructible<T1> and
                          __is_implicitly_constructible<T2>))
  tuple()
  requires std::is_default_constructible_v<T0> and
           std::is_default_constructible_v<T1> and
           std::is_default_constructible_v<T2>
  : __x0()
  , __x1()
  , __x2()
  {}

  constexpr explicit(not (is_convertible_v<T0 const&, T0> and
                          is_convertible_v<T1 const&, T1> and
                          is_convertible_v<T2 const&, T2>))
  tuple(T0 const& t0, T1 const& t1, T2 const& t2)
  requires std::is_copy_constructible_v<T0> and
           std::is_copy_constructible_v<T1> and
           std::is_copy_constructible_v<T2>
  : __x0(t0)
  , __x1(t1)
  , __x2(t2)
  {}

  template<class U0, class U1, class U2>
  requires is_constructible_v<T0, U0> and
           is_constructible_v<T1, U1> and
           is_constructible_v<T2, U2> and
           (not std::same_as<std::remove_cvref_t<U0>, allocator_arg_t> or
                std::same_as<std::remove_cvref_t<T0>, allocator_arg_t>)
  constexpr explicit(not (is_convertible_v<U0, T0> and
                          is_convertible_v<U1, T1> and
                          is_convertible_v<U2, T2>))
  tuple(U0&& u0, U1&& u1, U2&& u2)
  : __x0(std::forward<U0>(u0))
  , __x1(std::forward<U1>(u1))
  , __x2(std::forward<U2>(u2))
  {}

  template<class U0, class U1, class U2>
  requires is_constructible_v<T0, U0&> and
           is_constructible_v<T1, U1&> and
           is_constructible_v<T2, U2&>
  constexpr explicit(not (is_convertible_v<U0&, T0> and
                          is_convertible_v<U1&, T1> and
                          is_convertible_v<U2&, T2>))
  tuple(tuple<U0, U1, U2>& t)
  : __x0(std::forward<U0>(t.__x0))
  , __x1(std::forward<U1>(t.__x1))
  , __x2(std::forward<U2>(t.__x2))
  {}

  template<class U0, class U1, class U2>
  requires is_constructible_v<T0, U0 const&> and
           is_constructible_v<T1, U1 const&> and
           is_constructible_v<T2, U2 const&>
  constexpr explicit(not (is_convertible_v<U0 const&, T0> and
                          is_convertible_v<U1 const&, T1> and
                          is_convertible_v<U2 const&, T2>))
  tuple(tuple<U0, U1, U2> const& t)
  : __x0(std::forward<U0 const>(t.__x0))
  , __x1(std::forward<U1 const>(t.__x1))
  , __x2(std::forward<U2 const>(t.__x2))
  {}

  template<class U0, class U1, class U2>
  requires is_constructible_v<T0, U0&&> and
           is_constructible_v<T1, U1&&> and
           is_constructible_v<T2, U2&&>
  constexpr explicit(not (is_convertible_v<U0&&, T0> and
                          is_convertible_v<U1&&, T1> and
                          is_convertible_v<U2&&, T2>))
  tuple(tuple<U0, U1, U2>&& t)
  : __x0(std::forward<U0>(t.__x0))
  , __x1(std::forward<U1>(t.__x1))
  , __x2(std::forward<U2>(t.__x2))
  {}

  template<class U0, class U1, class U2>
  requires is_constructible_v<T0, U0 const&&> and
           is_constructible_v<T1, U1 const&&> and
           is_constructible_v<T2, U2 const&&>
  constexpr explicit(not (is_convertible_v<U0 const&&, T0> and
                          is_convertible_v<U1 const&&, T1> and
                          is_convertible_v<U2 const&&, T2>))
  tuple(tuple<U0, U1, U2> const&& t)
  : __x0(std::forward<U0 const>(t.__x0))
  , __x1(std::forward<U1 const>(t.__x1))
  , __x2(std::forward<U2 const>(t.__x2))
  {}

  template<class Alloc>
  requires __constructible_with_allocator<T0, Alloc const&> and
           __constructible_with_allocator<T1, Alloc const&> and
           __constructible_with_allocator<T2, Alloc const&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&> and
                          __is_implicitly_constructible<T1, Alloc const&> and
                          __is_implicitly_constructible<T2, Alloc const&>))
  tuple(allocator_arg_t, Alloc const& a)
  : __x0(__construct_with_allocator<T0>(a))
  , __x1(__construct_with_allocator<T1>(a))
  , __x2(__construct_with_allocator<T2>(a))
  {}

  template<class Alloc>
  requires __constructible_with_allocator<T0, Alloc const&, T0 const&> and
           __constructible_with_allocator<T1, Alloc const&, T1 const&> and
           __constructible_with_allocator<T2, Alloc const&, T2 const&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, T0 const&> and
                          __is_implicitly_constructible<T1, Alloc const&, T1 const&> and
                          __is_implicitly_constructible<T2, Alloc const&, T2 const&>))
  tuple(allocator_arg_t, Alloc const& a, T0 const& t0, T1 const& t1, T2 const& t2)
  : __x0(__construct_with_allocator<T0>(a, t0))
  , __x1(__construct_with_allocator<T1>(a, t1))
  , __x2(__construct_with_allocator<T2>(a, t2))
  {}

  template<class Alloc, class U0, class U1, class U2>
  requires __constructible_with_allocator<T0, Alloc const&, U0> and
           __constructible_with_allocator<T1, Alloc const&, U1> and
           __constructible_with_allocator<T2, Alloc const&, U2> and
           (not std::is_same_v<std::remove_cvref_t<U0>, allocator_arg_t> or
                std::is_same_v<std::remove_cvref_t<T0>, allocator_arg_t>)
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0> and
                          __is_implicitly_constructible<T1, Alloc const&, U1> and
                          __is_implicitly_constructible<T2, Alloc const&, U2>))
  tuple(allocator_arg_t, Alloc const& a, U0&& u0, U1&& u1, U2&& u2)
  : __x0(__construct_with_allocator<T0>(a, std::forward<U0>(u0)))
  , __x1(__construct_with_allocator<T1>(a, std::forward<U0>(u1)))
  , __x2(__construct_with_allocator<T2>(a, std::forward<U0>(u2)))
  {}

  template<class Alloc>
  requires __constructible_with_allocator<T0, Alloc const&, T0 const&> and
           __constructible_with_allocator<T1, Alloc const&, T1 const&> and
           __constructible_with_allocator<T2, Alloc const&, T2 const&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, T0 const&> and
                          __is_implicitly_constructible<T1, Alloc const&, T1 const&> and
                          __is_implicitly_constructible<T2, Alloc const&, T2 const&>))
  tuple(allocator_arg_t, Alloc const& a, tuple const& other)
  : __x0(__construct_with_allocator<T0>(a, other.__x0))
  , __x1(__construct_with_allocator<T1>(a, other.__x1))
  , __x2(__construct_with_allocator<T2>(a, other.__x2))
  {}

  template<class Alloc>
  requires __constructible_with_allocator<T0, Alloc const&, T0&&> and
           __constructible_with_allocator<T1, Alloc const&, T1&&> and
           __constructible_with_allocator<T2, Alloc const&, T2&&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, T0&&> and
                          __is_implicitly_constructible<T1, Alloc const&, T1&&> and
                          __is_implicitly_constructible<T2, Alloc const&, T2&&>))
  tuple(allocator_arg_t, Alloc const& a, tuple&& other)
  : __x0(__construct_with_allocator<T0>(a, std::move(other.__x0)))
  , __x1(__construct_with_allocator<T1>(a, std::move(other.__x1)))
  , __x2(__construct_with_allocator<T2>(a, std::move(other.__x2)))
  {}

  template<class Alloc, class U0, class U1, class U2>
  requires __constructible_with_allocator<T0, Alloc const&, U0&> and
           __constructible_with_allocator<T1, Alloc const&, U1&> and
           __constructible_with_allocator<T2, Alloc const&, U2&>
  constexpr explicit(not (is_convertible_v<U0&, T0> and
                          is_convertible_v<U1&, T1> and
                          is_convertible_v<U2&, T2>))
  tuple(allocator_arg_t, Alloc const& a, tuple<U0, U1, U2>& u)
  : __x0(__construct_with_allocator<T0>(a, u.__x0))
  , __x1(__construct_with_allocator<T1>(a, u.__x1))
  , __x2(__construct_with_allocator<T2>(a, u.__x2))
  {}

  template<class Alloc, class U0, class U1, class U2>
  requires __constructible_with_allocator<T0, Alloc const&, U0 const&> and
           __constructible_with_allocator<T1, Alloc const&, U1 const&> and
           __constructible_with_allocator<T2, Alloc const&, U2 const&>
  constexpr explicit(not (is_convertible_v<U0 const&, T0> and
                          is_convertible_v<U1 const&, T1> and
                          is_convertible_v<U2 const&, T2>))
  tuple(allocator_arg_t, Alloc const& a, tuple<U0, U1, U2> const& u)
  : __x0(__construct_with_allocator<T0>(a, u.__x0))
  , __x1(__construct_with_allocator<T1>(a, u.__x1))
  , __x2(__construct_with_allocator<T2>(a, u.__x2))
  {}

  template<class Alloc, class U0, class U1, class U2>
  requires __constructible_with_allocator<T0, Alloc const&, U0&&> and
           __constructible_with_allocator<T1, Alloc const&, U1&&> and
           __constructible_with_allocator<T2, Alloc const&, U2&&>
  constexpr explicit(not (is_convertible_v<U0&&, T0> and
                          is_convertible_v<U1&&, T1> and
                          is_convertible_v<U2&&, T2>))
  tuple(allocator_arg_t, Alloc const& a, tuple<U0, U1, U2>&& u)
  : __x0(__construct_with_allocator<T0>(a, std::move(u.__x0)))
  , __x1(__construct_with_allocator<T1>(a, std::move(u.__x1)))
  , __x2(__construct_with_allocator<T2>(a, std::move(u.__x2)))
  {}

  template<class Alloc, class U0, class U1, class U2>
  requires __constructible_with_allocator<T0, Alloc const&, U0 const&&> and
           __constructible_with_allocator<T1, Alloc const&, U1 const&&>
  constexpr explicit(not (is_convertible_v<U0 const&&, T0> and
                          is_convertible_v<U1 const&&, T1> and
                          is_convertible_v<U1 const&&, T2>))
  tuple(allocator_arg_t, Alloc const& a, tuple<U0, U1, U2> const&& u)
  : __x0(__construct_with_allocator<T0>(a, std::move(u.__x0)))
  , __x1(__construct_with_allocator<T1>(a, std::move(u.__x1)))
  , __x2(__construct_with_allocator<T2>(a, std::move(u.__x2)))
  {}

  // template<class Alloc, tuple-like UTuple>
  // constexpr explicit(see below) tuple(allocator_arg_t, const Alloc& a, UTuple&&);

  tuple(tuple const&) = default;
  tuple(tuple&&) = default;

  // [tuple.assign], tuple assignment
  constexpr tuple& operator=(tuple const&) = default;
  constexpr tuple& operator=(tuple&&) = default;

  constexpr const tuple& operator=(tuple const& other) const
  requires std::is_copy_assignable_v<T0 const> and
           std::is_copy_assignable_v<T1 const> and
           std::is_copy_assignable_v<T2 const>
  {
    [[clang::always_inline]] __x0 = other.__x0;
    [[clang::always_inline]] __x1 = other.__x1;
    [[clang::always_inline]] __x2 = other.__x2;
    return *this;
  }

  constexpr const tuple& operator=(tuple&& other) const
  requires std::is_assignable_v<T0 const&, T0> and
           std::is_assignable_v<T1 const&, T1> and
           std::is_assignable_v<T2 const&, T2>
  {
    [[clang::always_inline]] swap(std::move(other));
    return *this;
  }

  template<class U0, class U1, class U2>
  requires std::is_assignable_v<T0&, U0 const&> and
           std::is_assignable_v<T1&, U1 const&> and
           std::is_assignable_v<T2&, U2 const&>
  constexpr tuple& operator=(tuple<U0, U1, U2> const& other)
  {
    [[clang::always_inline]] __x0 = other.__x0;
    [[clang::always_inline]] __x1 = other.__x1;
    [[clang::always_inline]] __x2 = other.__x2;
    return *this;
  }

  template<class U0, class U1, class U2>
  requires std::is_assignable_v<T0 const&, U0 const&> and
           std::is_assignable_v<T1 const&, U1 const&> and
           std::is_assignable_v<T2 const&, U2 const&>
  constexpr tuple const& operator=(tuple<U0, U1, U2> const& other) const
  {
    [[clang::always_inline]] __x0 = other.__x0;
    [[clang::always_inline]] __x1 = other.__x1;
    [[clang::always_inline]] __x2 = other.__x2;
    return *this;
  }

  template<class U0, class U1, class U2>
  requires std::is_assignable_v<T0&, U0> and
           std::is_assignable_v<T1&, U1> and
           std::is_assignable_v<T2&, U2>
  constexpr tuple& operator=(tuple<U0, U1, U2>&& other)
  {
    [[clang::always_inline]] __x0 = std::move(other.__x0);
    [[clang::always_inline]] __x1 = std::move(other.__x1);
    [[clang::always_inline]] __x2 = std::move(other.__x2);
    return *this;
  }

  template<class U0, class U1, class U2>
  requires std::is_assignable_v<T0 const&, U0 const> and
           std::is_assignable_v<T1 const&, U1 const> and
           std::is_assignable_v<T2 const&, U2 const>
  constexpr tuple const& operator=(tuple<U0, U1, U2> const&& other) const
  {
    [[clang::always_inline]] __x0 = std::move(other.__x0);
    [[clang::always_inline]] __x1 = std::move(other.__x1);
    [[clang::always_inline]] __x2 = std::move(other.__x2);
    return *this;
  }

  // template<tuple-like UTuple>
  // constexpr tuple& operator=(UTuple&&);
  // template<tuple-like UTuple>
  // constexpr const tuple& operator=(UTuple&&) const;

  // [tuple.swap], tuple swap

  constexpr void swap(tuple& other) noexcept(std::is_nothrow_swappable_v<T0> and
                                             std::is_nothrow_swappable_v<T1> and
                                             std::is_nothrow_swappable_v<T2>)
  requires std::swappable<T0> and
           std::swappable<T1> and
           std::swappable<T2>
  {
    [[clang::always_inline]] std::ranges::swap(__x0, other.__x0);
    [[clang::always_inline]] std::ranges::swap(__x1, other.__x1);
    [[clang::always_inline]] std::ranges::swap(__x2, other.__x2);
  }

  constexpr void swap(tuple const& other) const noexcept(std::is_nothrow_swappable_v<T0 const> and
                                                         std::is_nothrow_swappable_v<T1 const> and
                                                         std::is_nothrow_swappable_v<T2 const>)
  requires std::swappable<T0 const> and
           std::swappable<T1 const> and
           std::swappable<T2 const>
  {
    [[clang::always_inline]] std::ranges::swap(__x0, other.__x0);
    [[clang::always_inline]] std::ranges::swap(__x1, other.__x1);
    [[clang::always_inline]] std::ranges::swap(__x2, other.__x2);
  }

  template<std::equality_comparable_with<T0> U0,
           std::equality_comparable_with<T1> U1,
           std::equality_comparable_with<T2> U2>
  friend constexpr bool operator==(tuple const& t, tuple<U0, U1, U2> const& u)
  {
      return t.__x0 == u.__x0 and
             t.__x1 == u.__x1 and
             t.__x2 == u.__x2;
  }

  template<__synth_three_way_comparable_with<T0> U0,
           __synth_three_way_comparable_with<T1> U1,
           __synth_three_way_comparable_with<T2> U2>
  friend constexpr auto operator<=>(tuple const& t, tuple<U0, U1, U2> const& u)
  -> common_comparison_category_t<__synth_three_way_result<T0, U0>,
                                  __synth_three_way_result<T1, U1>,
                                  __synth_three_way_result<T2, U2>>
  {
    if (auto result = __synth_three_way(t.__x0, u.__x0); result != std::partial_ordering::equivalent) {
      return result;
    }

    if (auto result = __synth_three_way(t.__x1, u.__x1); result != std::partial_ordering::equivalent) {
      return __synth_three_way(t.__x1, u.__x1);
    }

    return __synth_three_way(t.__x2, u.__x2);
  }
};
/*
template<class T0, class T1, class T2, class T3>
class _LIBCPP_TEMPLATE_VIS tuple<T0, T1, T2, T3> {
public:
  [[no_unique_address]] T0 __x0;
  [[no_unique_address]] T1 __x1;
  [[no_unique_address]] T2 __x2;
  [[no_unique_address]] T3 __x3;

  constexpr explicit(not (__is_implicitly_constructible<T0> and
                          __is_implicitly_constructible<T1> and
                          __is_implicitly_constructible<T2> and
                          __is_implicitly_constructible<T3>))
  tuple()
  requires std::is_default_constructible_v<T0> and
           std::is_default_constructible_v<T1> and
           std::is_default_constructible_v<T2> and
           std::is_default_constructible_v<T3>
  : __x0()
  , __x1()
  , __x2()
  , __x3()
  {}

  constexpr explicit(not (is_convertible_v<T0 const&, T0> and
                          is_convertible_v<T1 const&, T1> and
                          is_convertible_v<T2 const&, T2> and
                          is_convertible_v<T3 const&, T3>))
  tuple(T0 const& t0, T1 const& t1, T2 const& t2, T3 const& t3)
  requires std::is_copy_constructible_v<T0> and
           std::is_copy_constructible_v<T1> and
           std::is_copy_constructible_v<T2> and
           std::is_copy_constructible_v<T3>
  : __x0(t0)
  , __x1(t1)
  , __x2(t2)
  , __x3(t3)
  {}

  template<class U0, class U1, class U2, class U3>
  requires is_constructible_v<T0, U0> and
           is_constructible_v<T1, U1> and
           is_constructible_v<T2, U2> and
           is_constructible_v<T3, U3>
  constexpr explicit(not (is_convertible_v<U0, T0> and
                          is_convertible_v<U1, T1> and
                          is_convertible_v<U2, T2> and
                          is_convertible_v<U3, T3>))
  tuple(U0&& u0, U1&& u1, U2&& u2, U3&& u3)
  : __x0(std::forward<U0>(u0))
  , __x1(std::forward<U1>(u1))
  , __x2(std::forward<U2>(u2))
  , __x3(std::forward<U3>(u3))
  {}

  template<class U0, class U1, class U2, class U3>
  requires is_constructible_v<T0, U0&> and
           is_constructible_v<T1, U1&> and
           is_constructible_v<T2, U2&> and
           is_constructible_v<T3, U3&>
  constexpr explicit(not (is_convertible_v<U0&, T0> and
                          is_convertible_v<U1&, T1> and
                          is_convertible_v<U2&, T2> and
                          is_convertible_v<U3&, T3>))
  tuple(tuple<U0, U1, U2, U3>& t)
  : __x0(std::forward<U0>(t.__x0))
  , __x1(std::forward<U1>(t.__x1))
  , __x2(std::forward<U2>(t.__x2))
  , __x3(std::forward<U3>(t.__x3))
  {}

  template<class U0, class U1, class U2, class U3>
  requires is_constructible_v<T0, U0 const&> and
           is_constructible_v<T1, U1 const&> and
           is_constructible_v<T2, U2 const&> and
           is_constructible_v<T3, U3 const&>
  constexpr explicit(not (is_convertible_v<U0 const&, T0> and
                          is_convertible_v<U1 const&, T1> and
                          is_convertible_v<U2 const&, T2> and
                          is_convertible_v<U3 const&, T3>))
  tuple(tuple<U0, U1, U2, U3> const& t)
  : __x0(std::forward<U0 const>(t.__x0))
  , __x1(std::forward<U1 const>(t.__x1))
  , __x2(std::forward<U2 const>(t.__x2))
  , __x3(std::forward<U3 const>(t.__x3))
  {}

  template<class U0, class U1, class U2, class U3>
  requires is_constructible_v<T0, U0&&> and
           is_constructible_v<T1, U1&&> and
           is_constructible_v<T2, U2&&> and
           is_constructible_v<T3, U3&&>
  constexpr explicit(not (is_convertible_v<U0&&, T0> and
                          is_convertible_v<U1&&, T1> and
                          is_convertible_v<U2&&, T2> and
                          is_convertible_v<U3&&, T3>))
  tuple(tuple<U0, U1, U2, U3>&& t)
  : __x0(std::forward<U0>(t.__x0))
  , __x1(std::forward<U1>(t.__x1))
  , __x2(std::forward<U2>(t.__x2))
  , __x3(std::forward<U3>(t.__x3))
  {}

  template<class U0, class U1, class U2, class U3>
  requires is_constructible_v<T0, U0 const&&> and
           is_constructible_v<T1, U1 const&&> and
           is_constructible_v<T2, U2 const&&> and
           is_constructible_v<T3, U3 const&&>
  constexpr explicit(not (is_convertible_v<U0 const&&, T0> and
                          is_convertible_v<U1 const&&, T1> and
                          is_convertible_v<U2 const&&, T2> and
                          is_convertible_v<U3 const&&, T3>))
  tuple(tuple<U0, U1, U2, U3> const&& t)
  : __x0(std::forward<U0 const>(t.__x0))
  , __x1(std::forward<U1 const>(t.__x1))
  , __x2(std::forward<U2 const>(t.__x2))
  , __x3(std::forward<U3 const>(t.__x3))
  {}

  template<class Alloc>
  requires __constructible_with_allocator<T0, Alloc const&> and
           __constructible_with_allocator<T1, Alloc const&> and
           __constructible_with_allocator<T2, Alloc const&> and
           __constructible_with_allocator<T3, Alloc const&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&> and
                          __is_implicitly_constructible<T1, Alloc const&> and
                          __is_implicitly_constructible<T2, Alloc const&> and
                          __is_implicitly_constructible<T3, Alloc const&>))
  tuple(allocator_arg_t, Alloc const& a)
  : __x0(__construct_with_allocator<T0>(a))
  , __x1(__construct_with_allocator<T1>(a))
  , __x2(__construct_with_allocator<T2>(a))
  , __x3(__construct_with_allocator<T3>(a))
  {}

  template<class Alloc>
  requires __constructible_with_allocator<T0, Alloc const&, T0 const&> and
           __constructible_with_allocator<T1, Alloc const&, T1 const&> and
           __constructible_with_allocator<T2, Alloc const&, T2 const&> and
           __constructible_with_allocator<T3, Alloc const&, T3 const&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, T0 const&> and
                          __is_implicitly_constructible<T1, Alloc const&, T1 const&> and
                          __is_implicitly_constructible<T2, Alloc const&, T2 const&> and
                          __is_implicitly_constructible<T3, Alloc const&, T3 const&>))
  tuple(allocator_arg_t, Alloc const& a, T0 const& t0, T1 const& t1, T2 const& t2, T3 const& t3)
  : __x0(__construct_with_allocator<T0>(a, t0))
  , __x1(__construct_with_allocator<T1>(a, t1))
  , __x2(__construct_with_allocator<T2>(a, t2))
  , __x3(__construct_with_allocator<T3>(a, t3))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3>
  requires __constructible_with_allocator<T0, Alloc const&, U0&&> and
           __constructible_with_allocator<T1, Alloc const&, U1&&> and
           __constructible_with_allocator<T2, Alloc const&, U2&&> and
           __constructible_with_allocator<T3, Alloc const&, U3&&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0> and
                          __is_implicitly_constructible<T1, Alloc const&, U1> and
                          __is_implicitly_constructible<T2, Alloc const&, U2> and
                          __is_implicitly_constructible<T3, Alloc const&, U3>))
  tuple(allocator_arg_t, Alloc const& a, U0&& u0, U1&& u1, U2&& u2, U3&& u3)
  : __x0(__construct_with_allocator<T0>(a, std::forward<U0>(u0)))
  , __x1(__construct_with_allocator<T1>(a, std::forward<U0>(u1)))
  , __x2(__construct_with_allocator<T2>(a, std::forward<U0>(u2)))
  , __x3(__construct_with_allocator<T3>(a, std::forward<U0>(u3)))
  {}

  template<class Alloc>
  requires __constructible_with_allocator<T0, Alloc const&, T0 const&> and
           __constructible_with_allocator<T1, Alloc const&, T1 const&> and
           __constructible_with_allocator<T2, Alloc const&, T2 const&> and
           __constructible_with_allocator<T3, Alloc const&, T3 const&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, T0 const&> and
                          __is_implicitly_constructible<T1, Alloc const&, T1 const&> and
                          __is_implicitly_constructible<T2, Alloc const&, T2 const&> and
                          __is_implicitly_constructible<T3, Alloc const&, T3 const&>))
  tuple(allocator_arg_t, Alloc const& a, tuple const& other)
  : __x0(__construct_with_allocator<T0>(a, other.__x0))
  , __x1(__construct_with_allocator<T1>(a, other.__x1))
  , __x2(__construct_with_allocator<T2>(a, other.__x2))
  , __x3(__construct_with_allocator<T3>(a, other.__x3))
  {}

  template<class Alloc>
  requires __constructible_with_allocator<T0, Alloc const&, T0&&> and
           __constructible_with_allocator<T1, Alloc const&, T1&&> and
           __constructible_with_allocator<T2, Alloc const&, T2&&> and
           __constructible_with_allocator<T3, Alloc const&, T3&&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, T0&&> and
                          __is_implicitly_constructible<T1, Alloc const&, T1&&> and
                          __is_implicitly_constructible<T2, Alloc const&, T2&&> and
                          __is_implicitly_constructible<T3, Alloc const&, T3&&>))
  tuple(allocator_arg_t, Alloc const& a, tuple&& other)
  : __x0(__construct_with_allocator<T0>(a, std::move(other.__x0)))
  , __x1(__construct_with_allocator<T1>(a, std::move(other.__x1)))
  , __x2(__construct_with_allocator<T2>(a, std::move(other.__x2)))
  , __x3(__construct_with_allocator<T3>(a, std::move(other.__x3)))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3>
  requires __constructible_with_allocator<T0, Alloc const&, U0&> and
           __constructible_with_allocator<T1, Alloc const&, U1&> and
           __constructible_with_allocator<T2, Alloc const&, U2&> and
           __constructible_with_allocator<T3, Alloc const&, U3&>
  constexpr explicit(not (is_convertible_v<U0&, T0> and
                          is_convertible_v<U1&, T1> and
                          is_convertible_v<U2&, T2> and
                          is_convertible_v<U3&, T3>))
  tuple(allocator_arg_t, Alloc const& a, tuple<U0, U1, U2, U3>& u)
  : __x0(__construct_with_allocator<T0>(a, u.__x0))
  , __x1(__construct_with_allocator<T1>(a, u.__x1))
  , __x2(__construct_with_allocator<T2>(a, u.__x2))
  , __x3(__construct_with_allocator<T3>(a, u.__x3))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3>
  requires __constructible_with_allocator<T0, Alloc const&, U0 const&> and
           __constructible_with_allocator<T1, Alloc const&, U1 const&> and
           __constructible_with_allocator<T2, Alloc const&, U2 const&> and
           __constructible_with_allocator<T3, Alloc const&, U3 const&>
  constexpr explicit(not (is_convertible_v<U0 const&, T0> and
                          is_convertible_v<U1 const&, T1> and
                          is_convertible_v<U2 const&, T2> and
                          is_convertible_v<U3 const&, T3>))
  tuple(allocator_arg_t, Alloc const& a, tuple<U0, U1, U2, U3> const& u)
  : __x0(__construct_with_allocator<T0>(a, u.__x0))
  , __x1(__construct_with_allocator<T1>(a, u.__x1))
  , __x2(__construct_with_allocator<T2>(a, u.__x2))
  , __x3(__construct_with_allocator<T3>(a, u.__x3))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3>
  requires __constructible_with_allocator<T0, Alloc const&, U0&&> and
           __constructible_with_allocator<T1, Alloc const&, U1&&> and
           __constructible_with_allocator<T2, Alloc const&, U2&&> and
           __constructible_with_allocator<T3, Alloc const&, U3&&>
  constexpr explicit(not (is_convertible_v<U0, T0> and
                          is_convertible_v<U1, T1> and
                          is_convertible_v<U2, T2> and
                          is_convertible_v<U3, T3>))
  tuple(allocator_arg_t, Alloc const& a, tuple<U0, U1, U2, U3>&& u)
  : __x0(__construct_with_allocator<T0>(a, std::move(u.__x0)))
  , __x1(__construct_with_allocator<T1>(a, std::move(u.__x1)))
  , __x2(__construct_with_allocator<T2>(a, std::move(u.__x2)))
  , __x3(__construct_with_allocator<T3>(a, std::move(u.__x3)))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3>
  requires __constructible_with_allocator<T0, Alloc const&, U0 const&&> and
           __constructible_with_allocator<T1, Alloc const&, U1 const&&> and
           __constructible_with_allocator<T2, Alloc const&, U2 const&&> and
           __constructible_with_allocator<T3, Alloc const&, U3 const&&>
  constexpr explicit(not (is_convertible_v<U0 const, T0> and
                          is_convertible_v<U1 const, T1> and
                          is_convertible_v<U2 const, T2> and
                          is_convertible_v<U3 const, T3>))
  tuple(allocator_arg_t, Alloc const& a, tuple<U0, U1, U2, U3> const& u)
  : __x0(__construct_with_allocator<T0>(a, std::move(u.__x0)))
  , __x1(__construct_with_allocator<T1>(a, std::move(u.__x1)))
  , __x2(__construct_with_allocator<T2>(a, std::move(u.__x2)))
  , __x3(__construct_with_allocator<T3>(a, std::move(u.__x3)))
  {}

  // template<class Alloc, tuple-like UTuple>
  // constexpr explicit(see below) tuple(allocator_arg_t, const Alloc& a, UTuple&&);

  tuple(tuple const&) = default;
  tuple(tuple&&) = default;

  // [tuple.assign], tuple assignment
  constexpr tuple& operator=(tuple const&) = default;
  constexpr tuple& operator=(tuple&&) = default;

  constexpr const tuple& operator=(tuple const& other) const
  requires std::is_copy_assignable_v<T0 const> and
           std::is_copy_assignable_v<T1 const> and
           std::is_copy_assignable_v<T2 const> and
           std::is_copy_assignable_v<T3 const>
  {
    [[clang::always_inline]] __x0 = other.__x0;
    [[clang::always_inline]] __x1 = other.__x1;
    [[clang::always_inline]] __x2 = other.__x2;
    [[clang::always_inline]] __x3 = other.__x3;
    return *this;
  }

  constexpr const tuple& operator=(tuple&& other) const
  requires std::is_assignable_v<T0 const&, T0> and
           std::is_assignable_v<T1 const&, T1> and
           std::is_assignable_v<T2 const&, T2> and
           std::is_assignable_v<T3 const&, T3>
  {
    [[clang::always_inline]] swap(std::move(other));
    return *this;
  }

  template<class U0, class U1, class U2, class U3>
  requires std::is_assignable_v<T0&, U0 const&> and
           std::is_assignable_v<T1&, U1 const&> and
           std::is_assignable_v<T2&, U2 const&> and
           std::is_assignable_v<T3&, U3 const&>
  constexpr tuple& operator=(tuple<U0, U1, U2, U3> const& other)
  {
    [[clang::always_inline]] __x0 = other.__x0;
    [[clang::always_inline]] __x1 = other.__x1;
    [[clang::always_inline]] __x2 = other.__x2;
    [[clang::always_inline]] __x3 = other.__x3;
    return *this;
  }

  template<class U0, class U1, class U2, class U3>
  requires std::is_assignable_v<T0 const&, U0 const&> and
           std::is_assignable_v<T1 const&, U1 const&> and
           std::is_assignable_v<T2 const&, U2 const&> and
           std::is_assignable_v<T3 const&, U3 const&>
  constexpr tuple const& operator=(tuple<U0, U1, U2, U3> const& other) const
  {
    [[clang::always_inline]] __x0 = other.__x0;
    [[clang::always_inline]] __x1 = other.__x1;
    [[clang::always_inline]] __x2 = other.__x2;
    [[clang::always_inline]] __x3 = other.__32;
    return *this;
  }

  template<class U0, class U1, class U2, class U3>
  requires std::is_assignable_v<T0&, U0> and
           std::is_assignable_v<T1&, U1> and
           std::is_assignable_v<T2&, U2> and
           std::is_assignable_v<T3&, U3>
  constexpr tuple& operator=(tuple<U0, U1, U2, U3>&& other)
  {
    [[clang::always_inline]] __x0 = std::move(other.__x0);
    [[clang::always_inline]] __x1 = std::move(other.__x1);
    [[clang::always_inline]] __x2 = std::move(other.__x2);
    [[clang::always_inline]] __x3 = std::move(other.__x3);
    return *this;
  }

  template<class U0, class U1, class U2, class U3>
  requires is_assignable_v<T0 const&, U0 const> and
           is_assignable_v<T1 const&, U1 const> and
           is_assignable_v<T2 const&, U2 const> and
           is_assignable_v<T3 const&, U3 const>
  constexpr tuple const& operator=(tuple<U0, U1, U2> const&& other) const
  {
    [[clang::always_inline]] __x0 = std::move(other.__x0);
    [[clang::always_inline]] __x1 = std::move(other.__x1);
    [[clang::always_inline]] __x2 = std::move(other.__x2);
    [[clang::always_inline]] __x3 = std::move(other.__x3);
    return *this;
  }

  // template<tuple-like UTuple>
  // constexpr tuple& operator=(UTuple&&);
  // template<tuple-like UTuple>
  // constexpr const tuple& operator=(UTuple&&) const;

  // [tuple.swap], tuple swap

  constexpr void swap(tuple& other) noexcept(is_nothrow_swappable_v<T0> and
                                             is_nothrow_swappable_v<T1> and
                                             is_nothrow_swappable_v<T2> and
                                             is_nothrow_swappable_v<T3>)
  requires swappable<T0> and
           swappable<T1> and
           swappable<T2> and
           swappable<T3>
  {
    [[clang::always_inline]] std::ranges::swap(__x0, other.__x0);
    [[clang::always_inline]] std::ranges::swap(__x1, other.__x1);
    [[clang::always_inline]] std::ranges::swap(__x2, other.__x2);
    [[clang::always_inline]] std::ranges::swap(__x3, other.__x3);
  }

  constexpr void swap(tuple const& other) const noexcept(is_nothrow_swappable_v<T0 const> and
                                                         is_nothrow_swappable_v<T1 const> and
                                                         is_nothrow_swappable_v<T2 const> and
                                                         is_nothrow_swappable_v<T3 const>)
  requires swappable<T0 const> and
           swappable<T1 const> and
           swappable<T2 const> and
           swappable<T3 const>
  {
    [[clang::always_inline]] std::ranges::swap(__x0, other.__x0);
    [[clang::always_inline]] std::ranges::swap(__x1, other.__x1);
    [[clang::always_inline]] std::ranges::swap(__x2, other.__x2);
    [[clang::always_inline]] std::ranges::swap(__x3, other.__x3);
  }

  template<equality_comparable_with<T0> U0,
           equality_comparable_with<T1> U1,
           equality_comparable_with<T2> U2,
           equality_comparable_with<T3> U3>
  friend constexpr bool operator==(tuple const& t, tuple<U0, U1, U2, U3> const& u)
  {
      return t.__x0 == u.__x0 and
             t.__x1 == u.__x1 and
             t.__x2 == u.__x2 and
             t.__x3 == u.__x3;
  }

  template<__synth_three_way_comparable_with<T0> U0,
           __synth_three_way_comparable_with<T1> U1,
           __synth_three_way_comparable_with<T2> U2,
           __synth_three_way_comparable_with<T3> U3>
  friend constexpr auto operator<=>(tuple const& t, tuple<U0, U1, U2, U3> const& u)
  -> common_comparison_category_t<__synth_three_way_result<T0, U0>,
                                  __synth_three_way_result<T1, U1>,
                                  __synth_three_way_result<T2, U2>,
                                  __synth_three_way_result<T3, U3>>
  {
    if (auto result = __synth_three_way(t.__x0, u.__x0); result != std::partial_ordering::equivalent) {
      return result;
    }

    if (auto result = __synth_three_way(t.__x1, u.__x1); result != std::partial_ordering::equivalent) {
      return result;
    }

    if (auto result = __synth_three_way(t.__x2, u.__x2); result != std::partial_ordering::equivalent) {
      return result;
    }

    return __synth_three_way(t.__x3, u.__x3);
  }
};

template<class T0, class T1, class T2, class T3, class T4>
class _LIBCPP_TEMPLATE_VIS tuple<T0, T1, T2, T3, T4> {
public:
  [[no_unique_address]] T0 __x0;
  [[no_unique_address]] T1 __x1;
  [[no_unique_address]] T2 __x2;
  [[no_unique_address]] T3 __x3;
  [[no_unique_address]] T4 __x4;

  constexpr explicit(not (__is_implicitly_constructible<T0> and
                          __is_implicitly_constructible<T1> and
                          __is_implicitly_constructible<T2> and
                          __is_implicitly_constructible<T3> and
                          __is_implicitly_constructible<T4>))
  tuple()
  requires std::is_default_constructible_v<T0> and
           std::is_default_constructible_v<T1> and
           std::is_default_constructible_v<T2> and
           std::is_default_constructible_v<T3> and
           std::is_default_constructible_v<T4>
  : __x0()
  , __x1()
  , __x2()
  , __x3()
  , __x4()
  {}

  constexpr explicit(not (is_convertible_v<T0 const&, T0> and
                          is_convertible_v<T1 const&, T1> and
                          is_convertible_v<T2 const&, T2> and
                          is_convertible_v<T3 const&, T3> and
                          is_convertible_v<T4 const&, T4>))
  tuple(T0 const& t0, T1 const& t1, T2 const& t2, T3 const& t3, T4 const& t4)
  requires std::is_copy_constructible_v<T0> and
           std::is_copy_constructible_v<T1> and
           std::is_copy_constructible_v<T2> and
           std::is_copy_constructible_v<T3> and
           std::is_copy_constructible_v<T4>
  : __x0(t0)
  , __x1(t1)
  , __x2(t2)
  , __x3(t3)
  , __x4(t4)
  {}

  template<class U0, class U1, class U2, class U3, class U4>
  requires is_constructible_v<T0, U0> and
           is_constructible_v<T1, U1> and
           is_constructible_v<T2, U2> and
           is_constructible_v<T3, U3> and
           is_constructible_v<T4, U4>
  constexpr explicit(not (is_convertible_v<U0, T0> and
                          is_convertible_v<U1, T1> and
                          is_convertible_v<U2, T2> and
                          is_convertible_v<U3, T3> and
                          is_convertible_v<U4, T4>))
  tuple(U0&& u0, U1&& u1, U2&& u2, U3&& u3, U4&& u4)
  : __x0(std::forward<U0>(u0))
  , __x1(std::forward<U1>(u1))
  , __x2(std::forward<U2>(u2))
  , __x3(std::forward<U3>(u3))
  , __x4(std::forward<U4>(u4))
  {}

  template<class U0, class U1, class U2, class U3, class U4>
  requires is_constructible_v<T0, U0&> and
           is_constructible_v<T1, U1&> and
           is_constructible_v<T2, U2&> and
           is_constructible_v<T3, U3&> and
           is_constructible_v<T4, U4&>
  constexpr explicit(not (is_convertible_v<U0&, T0> and
                          is_convertible_v<U1&, T1> and
                          is_convertible_v<U2&, T2> and
                          is_convertible_v<U3&, T3> and
                          is_convertible_v<U4&, T4>))
  tuple(tuple<U0, U1, U2, U3, U4>& t)
  : __x0(std::forward<U0>(t.__x0))
  , __x1(std::forward<U1>(t.__x1))
  , __x2(std::forward<U2>(t.__x2))
  , __x3(std::forward<U3>(t.__x3))
  , __x4(std::forward<U4>(t.__x4))
  {}

  template<class U0, class U1, class U2, class U3, class U4>
  requires is_constructible_v<T0, U0 const&> and
           is_constructible_v<T1, U1 const&> and
           is_constructible_v<T2, U2 const&> and
           is_constructible_v<T3, U3 const&> and
           is_constructible_v<T4, U4 const&>
  constexpr explicit(not (is_convertible_v<U0 const&, T0> and
                          is_convertible_v<U1 const&, T1> and
                          is_convertible_v<U2 const&, T2> and
                          is_convertible_v<U3 const&, T3> and
                          is_convertible_v<U4 const&, T4>))
  tuple(tuple<U0, U1, U2, U3, U4> const& t)
  : __x0(std::forward<U0 const>(t.__x0))
  , __x1(std::forward<U1 const>(t.__x1))
  , __x2(std::forward<U2 const>(t.__x2))
  , __x3(std::forward<U3 const>(t.__x3))
  , __x4(std::forward<U4 const>(t.__x4))
  {}

  template<class U0, class U1, class U2, class U3, class U4>
  requires is_constructible_v<T0, U0> and
           is_constructible_v<T1, U1> and
           is_constructible_v<T2, U2> and
           is_constructible_v<T3, U3> and
           is_constructible_v<T4, U4>
  constexpr explicit(not (is_convertible_v<U0, T0> and
                          is_convertible_v<U1, T1> and
                          is_convertible_v<U2, T2> and
                          is_convertible_v<U3, T3> and
                          is_convertible_v<U4, T4>))
  tuple(tuple<U0, U1, U2, U3, U4>&& t)
  : __x0(std::forward<U0>(t.__x0))
  , __x1(std::forward<U1>(t.__x1))
  , __x2(std::forward<U2>(t.__x2))
  , __x3(std::forward<U3>(t.__x3))
  , __x4(std::forward<U4>(t.__x4))
  {}

  template<class U0, class U1, class U2, class U3, class U4>
  requires is_constructible_v<T0, U0 const> and
           is_constructible_v<T1, U1 const> and
           is_constructible_v<T2, U2 const> and
           is_constructible_v<T3, U3 const> and
           is_constructible_v<T4, U4 const>
  constexpr explicit(not (is_convertible_v<U0 const, T0> and
                          is_convertible_v<U1 const, T1> and
                          is_convertible_v<U2 const, T2> and
                          is_convertible_v<U3 const, T3> and
                          is_convertible_v<U4 const, T4>))
  tuple(tuple<U0, U1, U2, U3, U4> const&& t)
  : __x0(std::forward<U0 const>(t.__x0))
  , __x1(std::forward<U1 const>(t.__x1))
  , __x2(std::forward<U2 const>(t.__x2))
  , __x3(std::forward<U3 const>(t.__x3))
  , __x4(std::forward<U4 const>(t.__x4))
  {}

  template<class Alloc>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&> and
                          __is_implicitly_constructible<T1, Alloc const&> and
                          __is_implicitly_constructible<T2, Alloc const&> and
                          __is_implicitly_constructible<T3, Alloc const&> and
                          __is_implicitly_constructible<T4, Alloc const&>))
  tuple(allocator_arg_t, Alloc const& a)
  requires std::__constructible_with_allocator<T0, Alloc const&> and
           std::__constructible_with_allocator<T1, Alloc const&> and
           std::__constructible_with_allocator<T2, Alloc const&> and
           std::__constructible_with_allocator<T3, Alloc const&> and
           std::__constructible_with_allocator<T4, Alloc const&>
  : __x0(__construct_with_allocator<T0>(a))
  , __x1(__construct_with_allocator<T1>(a))
  , __x2(__construct_with_allocator<T2>(a))
  , __x3(__construct_with_allocator<T3>(a))
  , __x4(__construct_with_allocator<T4>(a))
  {}

  template<class Alloc>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, T0 const&> and
                          __is_implicitly_constructible<T1, Alloc const&, T1 const&> and
                          __is_implicitly_constructible<T2, Alloc const&, T2 const&> and
                          __is_implicitly_constructible<T3, Alloc const&, T3 const&> and
                          __is_implicitly_constructible<T4, Alloc const&, T4 const&>))
  tuple(allocator_arg_t, Alloc const& a, T0 const& t0, T1 const& t1, T2 const& t2, T3 const& t3, T4 const& t4)
  requires std::__constructible_with_allocator<T0, Alloc const&, T0 const&> and
           std::__constructible_with_allocator<T1, Alloc const&, T1 const&> and
           std::__constructible_with_allocator<T2, Alloc const&, T2 const&> and
           std::__constructible_with_allocator<T3, Alloc const&, T3 const&> and
           std::__constructible_with_allocator<T4, Alloc const&, T4 const&>
  : __x0(__construct_with_allocator<T0>(a, t0))
  , __x1(__construct_with_allocator<T1>(a, t1))
  , __x2(__construct_with_allocator<T2>(a, t2))
  , __x3(__construct_with_allocator<T3>(a, t3))
  , __x4(__construct_with_allocator<T4>(a, t4))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3, class U4>
  requires __constructible_with_allocator<T0, Alloc const&, U0> and
           __constructible_with_allocator<T1, Alloc const&, U1> and
           __constructible_with_allocator<T2, Alloc const&, U2> and
           __constructible_with_allocator<T3, Alloc const&, U3> and
           __constructible_with_allocator<T4, Alloc const&, U4>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0> and
                          __is_implicitly_constructible<T1, Alloc const&, U1> and
                          __is_implicitly_constructible<T2, Alloc const&, U2> and
                          __is_implicitly_constructible<T3, Alloc const&, U3> and
                          __is_implicitly_constructible<T4, Alloc const&, U4>))
  tuple(allocator_arg_t, Alloc const& alloc, U0&& u0, U1&& u1, U2&& u2, U3&& u3, U4&& u4)
  : __x0(__construct_with_allocator<T0>(alloc, std::forward<U0>(u0)))
  , __x1(__construct_with_allocator<T1>(alloc, std::forward<U1>(u1)))
  , __x2(__construct_with_allocator<T2>(alloc, std::forward<U2>(u2)))
  , __x3(__construct_with_allocator<T3>(alloc, std::forward<U3>(u3)))
  , __x4(__construct_with_allocator<T4>(alloc, std::forward<U4>(u4)))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3, class U4>
  requires __constructible_with_allocator<T0, Alloc const&, U0&> and
           __constructible_with_allocator<T1, Alloc const&, U1&> and
           __constructible_with_allocator<T2, Alloc const&, U2&> and
           __constructible_with_allocator<T3, Alloc const&, U3&> and
           __constructible_with_allocator<T4, Alloc const&, U4&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0&> and
                          __is_implicitly_constructible<T1, Alloc const&, U1&> and
                          __is_implicitly_constructible<T2, Alloc const&, U2&> and
                          __is_implicitly_constructible<T3, Alloc const&, U3&> and
                          __is_implicitly_constructible<T4, Alloc const&, U4&>))
  tuple(allocator_arg_t, Alloc const& alloc, tuple<U0, U1, U2, U3, U4>& t)
  : __x0(__construct_with_allocator<T0>(alloc, t.__x0))
  , __x1(__construct_with_allocator<T1>(alloc, t.__x1))
  , __x2(__construct_with_allocator<T2>(alloc, t.__x2))
  , __x3(__construct_with_allocator<T3>(alloc, t.__x3))
  , __x4(__construct_with_allocator<T4>(alloc, t.__x4))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3, class U4>
  requires __constructible_with_allocator<T0, Alloc const&, U0 const&> and
           __constructible_with_allocator<T1, Alloc const&, U1 const&> and
           __constructible_with_allocator<T2, Alloc const&, U2 const&> and
           __constructible_with_allocator<T3, Alloc const&, U3 const&> and
           __constructible_with_allocator<T4, Alloc const&, U4 const&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0 const&> and
                          __is_implicitly_constructible<T1, Alloc const&, U1 const&> and
                          __is_implicitly_constructible<T2, Alloc const&, U2 const&> and
                          __is_implicitly_constructible<T3, Alloc const&, U3 const&> and
                          __is_implicitly_constructible<T4, Alloc const&, U4 const&>))
  tuple(allocator_arg_t, Alloc const& alloc, tuple<U0, U1, U2, U3, U4> const& t)
  : __x0(__construct_with_allocator<T0>(alloc, t.__x0))
  , __x1(__construct_with_allocator<T1>(alloc, t.__x1))
  , __x2(__construct_with_allocator<T2>(alloc, t.__x2))
  , __x3(__construct_with_allocator<T3>(alloc, t.__x3))
  , __x4(__construct_with_allocator<T4>(alloc, t.__x4))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3, class U4>
  requires __constructible_with_allocator<T0, Alloc const&, U0&&> and
           __constructible_with_allocator<T1, Alloc const&, U1&&> and
           __constructible_with_allocator<T2, Alloc const&, U2&&> and
           __constructible_with_allocator<T3, Alloc const&, U3&&> and
           __constructible_with_allocator<T4, Alloc const&, U4&&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0&&> and
                          __is_implicitly_constructible<T1, Alloc const&, U1&&> and
                          __is_implicitly_constructible<T2, Alloc const&, U2&&> and
                          __is_implicitly_constructible<T3, Alloc const&, U3&&> and
                          __is_implicitly_constructible<T4, Alloc const&, U4&&>))
  tuple(allocator_arg_t, Alloc const& alloc, tuple<U0, U1, U2, U3, U4>&& t)
  : __x0(__construct_with_allocator<T0>(alloc, std::move(t.__x0)))
  , __x1(__construct_with_allocator<T1>(alloc, std::move(t.__x1)))
  , __x2(__construct_with_allocator<T2>(alloc, std::move(t.__x2)))
  , __x3(__construct_with_allocator<T3>(alloc, std::move(t.__x3)))
  , __x4(__construct_with_allocator<T4>(alloc, std::move(t.__x4)))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3, class U4>
  requires __constructible_with_allocator<T0, Alloc const&, U0 const&&> and
           __constructible_with_allocator<T1, Alloc const&, U1 const&&> and
           __constructible_with_allocator<T2, Alloc const&, U2 const&&> and
           __constructible_with_allocator<T3, Alloc const&, U3 const&&> and
           __constructible_with_allocator<T4, Alloc const&, U4 const&&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0 const&&> and
                          __is_implicitly_constructible<T1, Alloc const&, U1 const&&> and
                          __is_implicitly_constructible<T2, Alloc const&, U2 const&&> and
                          __is_implicitly_constructible<T3, Alloc const&, U3 const&&> and
                          __is_implicitly_constructible<T4, Alloc const&, U4 const&&>))
  tuple(allocator_arg_t, Alloc const& alloc, tuple<U0, U1, U2, U3, U4> const&& t)
  : __x0(__construct_with_allocator<T0>(alloc, std::move(t.__x0)))
  , __x1(__construct_with_allocator<T1>(alloc, std::move(t.__x1)))
  , __x2(__construct_with_allocator<T2>(alloc, std::move(t.__x2)))
  , __x3(__construct_with_allocator<T3>(alloc, std::move(t.__x3)))
  , __x4(__construct_with_allocator<T4>(alloc, std::move(t.__x4)))
  {}

  // template<class Alloc, tuple-like UTuple>
  // constexpr explicit(see below) tuple(allocator_arg_t, const Alloc& a, UTuple&&);

  tuple(tuple const&) = default;
  tuple(tuple&&) = default;

  // [tuple.assign], tuple assignment
  constexpr tuple& operator=(tuple const&) = default;
  constexpr tuple& operator=(tuple&&) = default;

  constexpr const tuple& operator=(tuple const& other) const
  requires std::is_copy_assignable_v<T0 const> and
           std::is_copy_assignable_v<T1 const> and
           std::is_copy_assignable_v<T2 const> and
           std::is_copy_assignable_v<T3 const> and
           std::is_copy_assignable_v<T4 const>
  {
    [[clang::always_inline]] __x0 = other.__x0;
    [[clang::always_inline]] __x1 = other.__x1;
    [[clang::always_inline]] __x2 = other.__x2;
    [[clang::always_inline]] __x3 = other.__x3;
    [[clang::always_inline]] __x4 = other.__x4;
    return *this;
  }

  constexpr const tuple& operator=(tuple&& other) const
  requires std::is_assignable_v<T0 const&, T0> and
           std::is_assignable_v<T1 const&, T1> and
           std::is_assignable_v<T2 const&, T2> and
           std::is_assignable_v<T3 const&, T3> and
           std::is_assignable_v<T4 const&, T4>
  {
    [[clang::always_inline]] swap(std::move(other));
    return *this;
  }

  template<class U0, class U1, class U2, class U3, class U4>
  requires std::is_assignable_v<T0&, U0 const&> and
           std::is_assignable_v<T1&, U1 const&> and
           std::is_assignable_v<T2&, U2 const&> and
           std::is_assignable_v<T3&, U3 const&> and
           std::is_assignable_v<T4&, U4 const&>
  constexpr tuple& operator=(tuple<U0, U1, U2, U3, U4> const& other)
  {
    [[clang::always_inline]] __x0 = other.__x0;
    [[clang::always_inline]] __x1 = other.__x1;
    [[clang::always_inline]] __x2 = other.__x2;
    [[clang::always_inline]] __x3 = other.__x3;
    [[clang::always_inline]] __x4 = other.__x4;
    return *this;
  }

  template<class U0, class U1, class U2, class U3, class U4>
  requires std::is_assignable_v<T0 const&, U0 const&> and
           std::is_assignable_v<T1 const&, U1 const&> and
           std::is_assignable_v<T2 const&, U2 const&> and
           std::is_assignable_v<T3 const&, U3 const&> and
           std::is_assignable_v<T4 const&, U4 const&>
  constexpr tuple& operator=(tuple<U0, U1, U2, U3, U4> const& other) const
  {
    [[clang::always_inline]] __x0 = other.__x0;
    [[clang::always_inline]] __x1 = other.__x1;
    [[clang::always_inline]] __x2 = other.__x2;
    [[clang::always_inline]] __x3 = other.__x3;
    [[clang::always_inline]] __x4 = other.__x4;
    return *this;
  }

  template<class U0, class U1, class U2, class U3, class U4>
  requires std::is_assignable_v<T0&, U0> and
           std::is_assignable_v<T1&, U1> and
           std::is_assignable_v<T2&, U2> and
           std::is_assignable_v<T3&, U3> and
           std::is_assignable_v<T4&, U4>
  constexpr tuple& operator=(tuple<U0, U1, U2, U3, U4>&& other)
  {
    [[clang::always_inline]] __x0 = std::move(other.__x0);
    [[clang::always_inline]] __x1 = std::move(other.__x1);
    [[clang::always_inline]] __x2 = std::move(other.__x2);
    [[clang::always_inline]] __x3 = std::move(other.__x3);
    [[clang::always_inline]] __x4 = std::move(other.__x4);
    return *this;
  }

  template<class U0, class U1, class U2, class U3, class U4>
  requires is_assignable_v<T0 const&, U0 const> and
           is_assignable_v<T1 const&, U1 const> and
           is_assignable_v<T2 const&, U2 const> and
           is_assignable_v<T3 const&, U3 const> and
           is_assignable_v<T4 const&, U4 const>
  constexpr tuple const& operator=(tuple<U0, U1, U2, U4> const&& other) const
  {
    [[clang::always_inline]] __x0 = std::move(other.__x0);
    [[clang::always_inline]] __x1 = std::move(other.__x1);
    [[clang::always_inline]] __x2 = std::move(other.__x2);
    [[clang::always_inline]] __x3 = std::move(other.__x3);
    [[clang::always_inline]] __x4 = std::move(other.__x4);
    return *this;
  }

  // template<tuple-like UTuple>
  // constexpr tuple& operator=(UTuple&&);
  // template<tuple-like UTuple>
  // constexpr const tuple& operator=(UTuple&&) const;

  // [tuple.swap], tuple swap

  constexpr void swap(tuple& other) noexcept(is_nothrow_swappable_v<T0> and
                                             is_nothrow_swappable_v<T1> and
                                             is_nothrow_swappable_v<T2> and
                                             is_nothrow_swappable_v<T3> and
                                             is_nothrow_swappable_v<T4>)
  requires swappable<T0> and
           swappable<T1> and
           swappable<T2> and
           swappable<T3> and
           swappable<T4>
  {
    [[clang::always_inline]] std::ranges::swap(__x0, other.__x0);
    [[clang::always_inline]] std::ranges::swap(__x1, other.__x1);
    [[clang::always_inline]] std::ranges::swap(__x2, other.__x2);
    [[clang::always_inline]] std::ranges::swap(__x3, other.__x3);
    [[clang::always_inline]] std::ranges::swap(__x4, other.__x4);
  }

  constexpr void swap(tuple const& other) const noexcept(is_nothrow_swappable_v<T0 const> and
                                                         is_nothrow_swappable_v<T1 const> and
                                                         is_nothrow_swappable_v<T2 const> and
                                                         is_nothrow_swappable_v<T3 const> and
                                                         is_nothrow_swappable_v<T4 const>)
  requires swappable<T0 const> and
           swappable<T1 const> and
           swappable<T2 const> and
           swappable<T3 const> and
           swappable<T4 const>
  {
    [[clang::always_inline]] std::ranges::swap(__x0, other.__x0);
    [[clang::always_inline]] std::ranges::swap(__x1, other.__x1);
    [[clang::always_inline]] std::ranges::swap(__x2, other.__x2);
    [[clang::always_inline]] std::ranges::swap(__x3, other.__x3);
    [[clang::always_inline]] std::ranges::swap(__x4, other.__x4);
  }

  template<equality_comparable_with<T0> U0,
           equality_comparable_with<T1> U1,
           equality_comparable_with<T2> U2,
           equality_comparable_with<T3> U3,
           equality_comparable_with<T4> U4>
  friend constexpr bool operator==(tuple const& t, tuple<U0, U1, U2, U3, U4> const& u)
  {
      return t.__x0 == u.__x0 and
             t.__x1 == u.__x1 and
             t.__x2 == u.__x2 and
             t.__x3 == u.__x3 and
             t.__x4 == u.__x4;
  }

  template<__synth_three_way_comparable_with<T0> U0,
           __synth_three_way_comparable_with<T1> U1,
           __synth_three_way_comparable_with<T2> U2,
           __synth_three_way_comparable_with<T3> U3,
           __synth_three_way_comparable_with<T4> U4>
  friend constexpr auto operator<=>(tuple const& t, tuple<U0, U1, U2, U3, U4> const& u)
  -> common_comparison_category_t<__synth_three_way_result<T0, U0>,
                                  __synth_three_way_result<T1, U1>,
                                  __synth_three_way_result<T2, U2>,
                                  __synth_three_way_result<T3, U3>,
                                  __synth_three_way_result<T4, U4>>
  {
    if (auto result = __synth_three_way(t.__x0, u.__x0); result != std::partial_ordering::equivalent) {
      return result;
    }

    if (auto result = __synth_three_way(t.__x1, u.__x1); result != std::partial_ordering::equivalent) {
      return result;
    }

    if (auto result = __synth_three_way(t.__x2, u.__x2); result != std::partial_ordering::equivalent) {
      return result;
    }

    if (auto result = __synth_three_way(t.__x3, u.__x3); result != std::partial_ordering::equivalent) {
      return result;
    }

    return __synth_three_way(t.__x4, u.__x4);
  }
};

template<class T0, class T1, class T2, class T3, class T4, class T5>
class _LIBCPP_TEMPLATE_VIS tuple<T0, T1, T2, T3, T4, T5> {
public:
  [[no_unique_address]] T0 __x0;
  [[no_unique_address]] T1 __x1;
  [[no_unique_address]] T2 __x2;
  [[no_unique_address]] T3 __x3;
  [[no_unique_address]] T4 __x4;
  [[no_unique_address]] T5 __x5;

  constexpr explicit(not (__is_implicitly_constructible<T0> and
                          __is_implicitly_constructible<T1> and
                          __is_implicitly_constructible<T2> and
                          __is_implicitly_constructible<T3> and
                          __is_implicitly_constructible<T4> and
                          __is_implicitly_constructible<T5>))
  tuple()
  requires std::is_default_constructible_v<T0> and
           std::is_default_constructible_v<T1> and
           std::is_default_constructible_v<T2> and
           std::is_default_constructible_v<T3> and
           std::is_default_constructible_v<T4> and
           std::is_default_constructible_v<T5>
  : __x0()
  , __x1()
  , __x2()
  , __x3()
  , __x4()
  , __x5()
  {}

  constexpr explicit(not (is_convertible_v<T0 const&, T0> and
                          is_convertible_v<T1 const&, T1> and
                          is_convertible_v<T2 const&, T2> and
                          is_convertible_v<T3 const&, T3> and
                          is_convertible_v<T4 const&, T4> and
                          is_convertible_v<T5 const&, T5>))
  tuple(T0 const& t0, T1 const& t1, T2 const& t2, T3 const& t3, T4 const& t4, T5 const& t5)
  requires std::is_copy_constructible_v<T0> and
           std::is_copy_constructible_v<T1> and
           std::is_copy_constructible_v<T2> and
           std::is_copy_constructible_v<T3> and
           std::is_copy_constructible_v<T4> and
           std::is_copy_constructible_v<T5>
  : __x0(t0)
  , __x1(t1)
  , __x2(t2)
  , __x3(t3)
  , __x4(t4)
  , __x5(t5)
  {}

  template<class U0, class U1, class U2, class U3, class U4, class U5>
  requires is_constructible_v<T0, U0> and
           is_constructible_v<T1, U1> and
           is_constructible_v<T2, U2> and
           is_constructible_v<T3, U3> and
           is_constructible_v<T4, U4> and
           is_constructible_v<T5, U5>
  constexpr explicit(not (is_convertible_v<U0, T0> and
                          is_convertible_v<U1, T1> and
                          is_convertible_v<U2, T2> and
                          is_convertible_v<U3, T3> and
                          is_convertible_v<U4, T4> and
                          is_convertible_v<U5, T5>))
  tuple(U0&& u0, U1&& u1, U2&& u2, U3&& u3, U4&& u4, U5&& u5)
  : __x0(std::forward<U0>(u0))
  , __x1(std::forward<U1>(u1))
  , __x2(std::forward<U2>(u2))
  , __x3(std::forward<U3>(u3))
  , __x4(std::forward<U4>(u4))
  , __x5(std::forward<U5>(u5))
  {}

  template<class U0, class U1, class U2, class U3, class U4, class U5>
  requires is_constructible_v<T0, U0&> and
           is_constructible_v<T1, U1&> and
           is_constructible_v<T2, U2&> and
           is_constructible_v<T3, U3&> and
           is_constructible_v<T4, U4&> and
           is_constructible_v<T5, U5&>
  constexpr explicit(not (is_convertible_v<U0&, T0> and
                          is_convertible_v<U1&, T1> and
                          is_convertible_v<U2&, T2> and
                          is_convertible_v<U3&, T3> and
                          is_convertible_v<U4&, T4> and
                          is_convertible_v<U5&, T5>))
  tuple(tuple<U0, U1, U2, U3, U4, U5>& t)
  : __x0(std::forward<U0>(t.__x0))
  , __x1(std::forward<U1>(t.__x1))
  , __x2(std::forward<U2>(t.__x2))
  , __x3(std::forward<U3>(t.__x3))
  , __x4(std::forward<U4>(t.__x4))
  , __x5(std::forward<U5>(t.__x5))
  {}

  template<class U0, class U1, class U2, class U3, class U4, class U5>
  requires is_constructible_v<T0, U0 const&> and
           is_constructible_v<T1, U1 const&> and
           is_constructible_v<T2, U2 const&> and
           is_constructible_v<T3, U3 const&> and
           is_constructible_v<T4, U4 const&> and
           is_constructible_v<T5, U5 const&>
  constexpr explicit(not (is_convertible_v<U0 const&, T0> and
                          is_convertible_v<U1 const&, T1> and
                          is_convertible_v<U2 const&, T2> and
                          is_convertible_v<U3 const&, T3> and
                          is_convertible_v<U4 const&, T4> and
                          is_convertible_v<U5 const&, T5>))
  tuple(tuple<U0, U1, U2, U3, U4, U5> const& t)
  : __x0(std::forward<U0 const>(t.__x0))
  , __x1(std::forward<U1 const>(t.__x1))
  , __x2(std::forward<U2 const>(t.__x2))
  , __x3(std::forward<U3 const>(t.__x3))
  , __x4(std::forward<U4 const>(t.__x4))
  , __x5(std::forward<U5 const>(t.__x5))
  {}

  template<class U0, class U1, class U2, class U3, class U4, class U5>
  requires is_constructible_v<T0, U0> and
           is_constructible_v<T1, U1> and
           is_constructible_v<T2, U2> and
           is_constructible_v<T3, U3> and
           is_constructible_v<T4, U4> and
           is_constructible_v<T5, U5>
  constexpr explicit(not (is_convertible_v<U0, T0> and
                          is_convertible_v<U1, T1> and
                          is_convertible_v<U2, T2> and
                          is_convertible_v<U3, T3> and
                          is_convertible_v<U4, T4> and
                          is_convertible_v<U5, T5>))
  tuple(tuple<U0, U1, U2, U3, U4, U5>&& t)
  : __x0(std::forward<U0>(t.__x0))
  , __x1(std::forward<U1>(t.__x1))
  , __x2(std::forward<U2>(t.__x2))
  , __x3(std::forward<U3>(t.__x3))
  , __x4(std::forward<U4>(t.__x4))
  , __x5(std::forward<U5>(t.__x5))
  {}

  template<class U0, class U1, class U2, class U3, class U4, class U5>
  requires is_constructible_v<T0, U0 const> and
           is_constructible_v<T1, U1 const> and
           is_constructible_v<T2, U2 const> and
           is_constructible_v<T3, U3 const> and
           is_constructible_v<T4, U4 const> and
           is_constructible_v<T5, U5 const>
  constexpr explicit(not (is_convertible_v<U0 const, T0> and
                          is_convertible_v<U1 const, T1> and
                          is_convertible_v<U2 const, T2> and
                          is_convertible_v<U3 const, T3> and
                          is_convertible_v<U4 const, T4> and
                          is_convertible_v<U5 const, T5>))
  tuple(tuple<U0, U1, U2, U3, U4, U5> const&& t)
  : __x0(std::forward<U0 const>(t.__x0))
  , __x1(std::forward<U1 const>(t.__x1))
  , __x2(std::forward<U2 const>(t.__x2))
  , __x3(std::forward<U3 const>(t.__x3))
  , __x4(std::forward<U4 const>(t.__x4))
  , __x5(std::forward<U5 const>(t.__x5))
  {}

  template<class Alloc>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&> and
                          __is_implicitly_constructible<T1, Alloc const&> and
                          __is_implicitly_constructible<T2, Alloc const&> and
                          __is_implicitly_constructible<T3, Alloc const&> and
                          __is_implicitly_constructible<T4, Alloc const&> and
                          __is_implicitly_constructible<T5, Alloc const&>))
  tuple(allocator_arg_t, Alloc const& a)
  requires std::__constructible_with_allocator<T0, Alloc const&> and
           std::__constructible_with_allocator<T1, Alloc const&> and
           std::__constructible_with_allocator<T2, Alloc const&> and
           std::__constructible_with_allocator<T3, Alloc const&> and
           std::__constructible_with_allocator<T4, Alloc const&> and
           std::__constructible_with_allocator<T5, Alloc const&>
  : __x0(__construct_with_allocator<T0>(a))
  , __x1(__construct_with_allocator<T1>(a))
  , __x2(__construct_with_allocator<T2>(a))
  , __x3(__construct_with_allocator<T3>(a))
  , __x4(__construct_with_allocator<T4>(a))
  , __x5(__construct_with_allocator<T5>(a))
  {}

  template<class Alloc>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, T0 const&> and
                          __is_implicitly_constructible<T1, Alloc const&, T1 const&> and
                          __is_implicitly_constructible<T2, Alloc const&, T2 const&> and
                          __is_implicitly_constructible<T3, Alloc const&, T3 const&> and
                          __is_implicitly_constructible<T4, Alloc const&, T4 const&> and
                          __is_implicitly_constructible<T5, Alloc const&, T5 const&>))
  tuple(allocator_arg_t, Alloc const& alloc, T0 const& t0, T1 const& t1, T2 const& t2, T3 const& t3, T4 const& t4, T5 const& t5)
  requires std::__constructible_with_allocator<T0, Alloc const&, T0 const&> and
           std::__constructible_with_allocator<T1, Alloc const&, T1 const&> and
           std::__constructible_with_allocator<T2, Alloc const&, T2 const&> and
           std::__constructible_with_allocator<T3, Alloc const&, T3 const&> and
           std::__constructible_with_allocator<T4, Alloc const&, T4 const&> and
           std::__constructible_with_allocator<T5, Alloc const&, T5 const&>
  : __x0(__construct_with_allocator<T0>(alloc, t0))
  , __x1(__construct_with_allocator<T1>(alloc, t1))
  , __x2(__construct_with_allocator<T2>(alloc, t2))
  , __x3(__construct_with_allocator<T3>(alloc, t3))
  , __x4(__construct_with_allocator<T4>(alloc, t4))
  , __x5(__construct_with_allocator<T5>(alloc, t5))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3, class U4, class U5>
  requires __constructible_with_allocator<T0, Alloc const&, U0> and
           __constructible_with_allocator<T1, Alloc const&, U1> and
           __constructible_with_allocator<T2, Alloc const&, U2> and
           __constructible_with_allocator<T3, Alloc const&, U3> and
           __constructible_with_allocator<T4, Alloc const&, U4> and
           __constructible_with_allocator<T5, Alloc const&, U5>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0> and
                          __is_implicitly_constructible<T1, Alloc const&, U1> and
                          __is_implicitly_constructible<T2, Alloc const&, U2> and
                          __is_implicitly_constructible<T3, Alloc const&, U3> and
                          __is_implicitly_constructible<T4, Alloc const&, U4> and
                          __is_implicitly_constructible<T5, Alloc const&, U5>))
  tuple(allocator_arg_t, Alloc const& alloc, U0&& u0, U1&& u1, U2&& u2, U3&& u3, U4&& u4, U5&& u5)
  : __x0(__construct_with_allocator<T0>(alloc, std::forward<U0>(u0)))
  , __x1(__construct_with_allocator<T1>(alloc, std::forward<U1>(u1)))
  , __x2(__construct_with_allocator<T2>(alloc, std::forward<U2>(u2)))
  , __x3(__construct_with_allocator<T3>(alloc, std::forward<U3>(u3)))
  , __x4(__construct_with_allocator<T4>(alloc, std::forward<U4>(u4)))
  , __x5(__construct_with_allocator<T5>(alloc, std::forward<U5>(u5)))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3, class U4, class U5>
  requires __constructible_with_allocator<T0, Alloc const&, U0&> and
           __constructible_with_allocator<T1, Alloc const&, U1&> and
           __constructible_with_allocator<T2, Alloc const&, U2&> and
           __constructible_with_allocator<T3, Alloc const&, U3&> and
           __constructible_with_allocator<T4, Alloc const&, U4&> and
           __constructible_with_allocator<T5, Alloc const&, U5&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0&> and
                          __is_implicitly_constructible<T1, Alloc const&, U1&> and
                          __is_implicitly_constructible<T2, Alloc const&, U2&> and
                          __is_implicitly_constructible<T3, Alloc const&, U3&> and
                          __is_implicitly_constructible<T4, Alloc const&, U4&> and
                          __is_implicitly_constructible<T5, Alloc const&, U5&>))
  tuple(allocator_arg_t, Alloc const& alloc, tuple<U0, U1, U2, U3, U4, U5>& t)
  : __x0(__construct_with_allocator<T0>(alloc, t.__x0))
  , __x1(__construct_with_allocator<T1>(alloc, t.__x1))
  , __x2(__construct_with_allocator<T2>(alloc, t.__x2))
  , __x3(__construct_with_allocator<T3>(alloc, t.__x3))
  , __x4(__construct_with_allocator<T4>(alloc, t.__x4))
  , __x5(__construct_with_allocator<T5>(alloc, t.__x5))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3, class U4, class U5>
  requires __constructible_with_allocator<T0, Alloc const&, U0 const&> and
           __constructible_with_allocator<T1, Alloc const&, U1 const&> and
           __constructible_with_allocator<T2, Alloc const&, U2 const&> and
           __constructible_with_allocator<T3, Alloc const&, U3 const&> and
           __constructible_with_allocator<T4, Alloc const&, U4 const&> and
           __constructible_with_allocator<T5, Alloc const&, U5 const&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0 const&> and
                          __is_implicitly_constructible<T1, Alloc const&, U1 const&> and
                          __is_implicitly_constructible<T2, Alloc const&, U2 const&> and
                          __is_implicitly_constructible<T3, Alloc const&, U3 const&> and
                          __is_implicitly_constructible<T4, Alloc const&, U4 const&> and
                          __is_implicitly_constructible<T5, Alloc const&, U5 const&>))
  tuple(allocator_arg_t, Alloc const& alloc, tuple<U0, U1, U2, U3, U4, U5> const& t)
  : __x0(__construct_with_allocator<T0>(alloc, t.__x0))
  , __x1(__construct_with_allocator<T1>(alloc, t.__x1))
  , __x2(__construct_with_allocator<T2>(alloc, t.__x2))
  , __x3(__construct_with_allocator<T3>(alloc, t.__x3))
  , __x4(__construct_with_allocator<T4>(alloc, t.__x4))
  , __x5(__construct_with_allocator<T5>(alloc, t.__x5))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3, class U4, class U5>
  requires __constructible_with_allocator<T0, Alloc const&, U0&&> and
           __constructible_with_allocator<T1, Alloc const&, U1&&> and
           __constructible_with_allocator<T2, Alloc const&, U2&&> and
           __constructible_with_allocator<T3, Alloc const&, U3&&> and
           __constructible_with_allocator<T4, Alloc const&, U4&&> and
           __constructible_with_allocator<T5, Alloc const&, U5&&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0&&> and
                          __is_implicitly_constructible<T1, Alloc const&, U1&&> and
                          __is_implicitly_constructible<T2, Alloc const&, U2&&> and
                          __is_implicitly_constructible<T3, Alloc const&, U3&&> and
                          __is_implicitly_constructible<T4, Alloc const&, U4&&> and
                          __is_implicitly_constructible<T5, Alloc const&, U5&&>))
  tuple(allocator_arg_t, Alloc const& alloc, tuple<U0, U1, U2, U3, U4, U5>&& t)
  : __x0(__construct_with_allocator<T0>(alloc, std::move(t.__x0)))
  , __x1(__construct_with_allocator<T1>(alloc, std::move(t.__x1)))
  , __x2(__construct_with_allocator<T2>(alloc, std::move(t.__x2)))
  , __x3(__construct_with_allocator<T3>(alloc, std::move(t.__x3)))
  , __x4(__construct_with_allocator<T4>(alloc, std::move(t.__x4)))
  , __x5(__construct_with_allocator<T5>(alloc, std::move(t.__x5)))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3, class U4, class U5>
  requires __constructible_with_allocator<T0, Alloc const&, U0 const&&> and
           __constructible_with_allocator<T1, Alloc const&, U1 const&&> and
           __constructible_with_allocator<T2, Alloc const&, U2 const&&> and
           __constructible_with_allocator<T3, Alloc const&, U3 const&&> and
           __constructible_with_allocator<T4, Alloc const&, U4 const&&> and
           __constructible_with_allocator<T5, Alloc const&, U5 const&&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0 const&&> and
                          __is_implicitly_constructible<T1, Alloc const&, U1 const&&> and
                          __is_implicitly_constructible<T2, Alloc const&, U2 const&&> and
                          __is_implicitly_constructible<T3, Alloc const&, U3 const&&> and
                          __is_implicitly_constructible<T4, Alloc const&, U4 const&&> and
                          __is_implicitly_constructible<T5, Alloc const&, U5 const&&>))
  tuple(allocator_arg_t, Alloc const& alloc, tuple<U0, U1, U2, U3, U4, U5> const&& t)
  : __x0(__construct_with_allocator<T0>(alloc, std::move(t.__x0)))
  , __x1(__construct_with_allocator<T1>(alloc, std::move(t.__x1)))
  , __x2(__construct_with_allocator<T2>(alloc, std::move(t.__x2)))
  , __x3(__construct_with_allocator<T3>(alloc, std::move(t.__x3)))
  , __x4(__construct_with_allocator<T4>(alloc, std::move(t.__x4)))
  , __x5(__construct_with_allocator<T5>(alloc, std::move(t.__x5)))
  {}

  // template<class Alloc, tuple-like UTuple>
  // constexpr explicit(see below) tuple(allocator_arg_t, const Alloc& a, UTuple&&);

  tuple(tuple const&) = default;
  tuple(tuple&&) = default;

  // [tuple.assign], tuple assignment
  constexpr tuple& operator=(tuple const&) = default;
  constexpr tuple& operator=(tuple&&) = default;

  constexpr const tuple& operator=(tuple const& other) const
  requires std::is_copy_assignable_v<T0 const> and
           std::is_copy_assignable_v<T1 const> and
           std::is_copy_assignable_v<T2 const> and
           std::is_copy_assignable_v<T3 const> and
           std::is_copy_assignable_v<T4 const> and
           std::is_copy_assignable_v<T5 const>
  {
    [[clang::always_inline]] __x0 = other.__x0;
    [[clang::always_inline]] __x1 = other.__x1;
    [[clang::always_inline]] __x2 = other.__x2;
    [[clang::always_inline]] __x3 = other.__x3;
    [[clang::always_inline]] __x4 = other.__x4;
    [[clang::always_inline]] __x5 = other.__x5;
    return *this;
  }

  constexpr const tuple& operator=(tuple&& other) const
  requires std::is_assignable_v<T0 const&, T0> and
           std::is_assignable_v<T1 const&, T1> and
           std::is_assignable_v<T2 const&, T2> and
           std::is_assignable_v<T3 const&, T3> and
           std::is_assignable_v<T4 const&, T4> and
           std::is_assignable_v<T5 const&, T5>
  {
    [[clang::always_inline]] swap(std::move(other));
    return *this;
  }

  template<class U0, class U1, class U2, class U3, class U4, class U5>
  requires std::is_assignable_v<T0&, U0 const&> and
           std::is_assignable_v<T1&, U1 const&> and
           std::is_assignable_v<T2&, U2 const&> and
           std::is_assignable_v<T3&, U3 const&> and
           std::is_assignable_v<T4&, U4 const&> and
           std::is_assignable_v<T5&, U5 const&>
  constexpr tuple& operator=(tuple<U0, U1, U2, U3, U4, U5> const& other)
  {
    [[clang::always_inline]] __x0 = other.__x0;
    [[clang::always_inline]] __x1 = other.__x1;
    [[clang::always_inline]] __x2 = other.__x2;
    [[clang::always_inline]] __x3 = other.__x3;
    [[clang::always_inline]] __x4 = other.__x4;
    [[clang::always_inline]] __x5 = other.__x5;
    return *this;
  }

  template<class U0, class U1, class U2, class U3, class U4, class U5>
  requires std::is_assignable_v<T0 const&, U0 const&> and
           std::is_assignable_v<T1 const&, U1 const&> and
           std::is_assignable_v<T2 const&, U2 const&> and
           std::is_assignable_v<T3 const&, U3 const&> and
           std::is_assignable_v<T4 const&, U4 const&> and
           std::is_assignable_v<T5 const&, U5 const&>
  constexpr tuple& operator=(tuple<U0, U1, U2, U3, U4, U5> const& other) const
  {
    [[clang::always_inline]] __x0 = other.__x0;
    [[clang::always_inline]] __x1 = other.__x1;
    [[clang::always_inline]] __x2 = other.__x2;
    [[clang::always_inline]] __x3 = other.__x3;
    [[clang::always_inline]] __x4 = other.__x4;
    [[clang::always_inline]] __x5 = other.__x5;
    return *this;
  }

  template<class U0, class U1, class U2, class U3, class U4, class U5>
  requires std::is_assignable_v<T0&, U0> and
           std::is_assignable_v<T1&, U1> and
           std::is_assignable_v<T2&, U2> and
           std::is_assignable_v<T3&, U3> and
           std::is_assignable_v<T4&, U4> and
           std::is_assignable_v<T5&, U5>
  constexpr tuple& operator=(tuple<U0, U1, U2, U3, U4, U5>&& other)
  {
    [[clang::always_inline]] __x0 = std::move(other.__x0);
    [[clang::always_inline]] __x1 = std::move(other.__x1);
    [[clang::always_inline]] __x2 = std::move(other.__x2);
    [[clang::always_inline]] __x3 = std::move(other.__x3);
    [[clang::always_inline]] __x4 = std::move(other.__x4);
    [[clang::always_inline]] __x5 = std::move(other.__x5);
    return *this;
  }

  template<class U0, class U1, class U2, class U3, class U4, class U5>
  requires is_assignable_v<T0 const&, U0 const> and
           is_assignable_v<T1 const&, U1 const> and
           is_assignable_v<T2 const&, U2 const> and
           is_assignable_v<T3 const&, U3 const> and
           is_assignable_v<T4 const&, U4 const> and
           is_assignable_v<T5 const&, U5 const>
  constexpr tuple const& operator=(tuple<U0, U1, U2, U4, U5> const&& other) const
  {
    [[clang::always_inline]] __x0 = std::move(other.__x0);
    [[clang::always_inline]] __x1 = std::move(other.__x1);
    [[clang::always_inline]] __x2 = std::move(other.__x2);
    [[clang::always_inline]] __x3 = std::move(other.__x3);
    [[clang::always_inline]] __x4 = std::move(other.__x4);
    [[clang::always_inline]] __x5 = std::move(other.__x5);
    return *this;
  }

  // template<tuple-like UTuple>
  // constexpr tuple& operator=(UTuple&&);
  // template<tuple-like UTuple>
  // constexpr const tuple& operator=(UTuple&&) const;

  // [tuple.swap], tuple swap

  constexpr void swap(tuple& other) noexcept(is_nothrow_swappable_v<T0> and
                                             is_nothrow_swappable_v<T1> and
                                             is_nothrow_swappable_v<T2> and
                                             is_nothrow_swappable_v<T3> and
                                             is_nothrow_swappable_v<T4> and
                                             is_nothrow_swappable_v<T5>)
  requires swappable<T0> and
           swappable<T1> and
           swappable<T2> and
           swappable<T3> and
           swappable<T4> and
           swappable<T5>
  {
    [[clang::always_inline]] std::ranges::swap(__x0, other.__x0);
    [[clang::always_inline]] std::ranges::swap(__x1, other.__x1);
    [[clang::always_inline]] std::ranges::swap(__x2, other.__x2);
    [[clang::always_inline]] std::ranges::swap(__x3, other.__x3);
    [[clang::always_inline]] std::ranges::swap(__x4, other.__x4);
    [[clang::always_inline]] std::ranges::swap(__x5, other.__x5);
  }

  constexpr void swap(tuple const& other) const noexcept(is_nothrow_swappable_v<T0 const> and
                                                         is_nothrow_swappable_v<T1 const> and
                                                         is_nothrow_swappable_v<T2 const> and
                                                         is_nothrow_swappable_v<T3 const> and
                                                         is_nothrow_swappable_v<T4 const> and
                                                         is_nothrow_swappable_v<T5 const>)
  requires swappable<T0 const> and
           swappable<T1 const> and
           swappable<T2 const> and
           swappable<T3 const> and
           swappable<T4 const> and
           swappable<T5 const>
  {
    [[clang::always_inline]] std::ranges::swap(__x0, other.__x0);
    [[clang::always_inline]] std::ranges::swap(__x1, other.__x1);
    [[clang::always_inline]] std::ranges::swap(__x2, other.__x2);
    [[clang::always_inline]] std::ranges::swap(__x3, other.__x3);
    [[clang::always_inline]] std::ranges::swap(__x4, other.__x4);
    [[clang::always_inline]] std::ranges::swap(__x5, other.__x5);
  }

  template<equality_comparable_with<T0> U0,
           equality_comparable_with<T1> U1,
           equality_comparable_with<T2> U2,
           equality_comparable_with<T3> U3,
           equality_comparable_with<T4> U4,
           equality_comparable_with<T5> U5>
  friend constexpr bool operator==(tuple const& t, tuple<U0, U1, U2, U3, U4, U5> const& u)
  {
      return t.__x0 == u.__x0 and
             t.__x1 == u.__x1 and
             t.__x2 == u.__x2 and
             t.__x3 == u.__x3 and
             t.__x4 == u.__x4 and
             t.__x5 == u.__x5;
  }

  template<__synth_three_way_comparable_with<T0> U0,
           __synth_three_way_comparable_with<T1> U1,
           __synth_three_way_comparable_with<T2> U2,
           __synth_three_way_comparable_with<T3> U3,
           __synth_three_way_comparable_with<T4> U4,
           __synth_three_way_comparable_with<T5> U5>
  friend constexpr auto operator<=>(tuple const& t, tuple<U0, U1, U2, U3, U4, U5> const& u)
  -> common_comparison_category_t<__synth_three_way_result<T0, U0>,
                                  __synth_three_way_result<T1, U1>,
                                  __synth_three_way_result<T2, U2>,
                                  __synth_three_way_result<T3, U3>,
                                  __synth_three_way_result<T4, U4>,
                                  __synth_three_way_result<T5, U5>>
  {
    if (auto result = __synth_three_way(t.__x0, u.__x0); result != std::partial_ordering::equivalent) {
      return result;
    }

    if (auto result = __synth_three_way(t.__x1, u.__x1); result != std::partial_ordering::equivalent) {
      return result;
    }

    if (auto result = __synth_three_way(t.__x2, u.__x2); result != std::partial_ordering::equivalent) {
      return result;
    }

    if (auto result = __synth_three_way(t.__x3, u.__x3); result != std::partial_ordering::equivalent) {
      return result;
    }

    if (auto result = __synth_three_way(t.__x4, u.__x4); result != std::partial_ordering::equivalent) {
      return result;
    }

    return __synth_three_way(t.__x5, u.__x5);
  }
};

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6>
class _LIBCPP_TEMPLATE_VIS tuple<T0, T1, T2, T3, T4, T5, T6> {
public:
  [[no_unique_address]] T0 __x0;
  [[no_unique_address]] T1 __x1;
  [[no_unique_address]] T2 __x2;
  [[no_unique_address]] T3 __x3;
  [[no_unique_address]] T4 __x4;
  [[no_unique_address]] T5 __x5;
  [[no_unique_address]] T6 __x6;

  constexpr explicit(not (__is_implicitly_constructible<T0> and
                          __is_implicitly_constructible<T1> and
                          __is_implicitly_constructible<T2> and
                          __is_implicitly_constructible<T3> and
                          __is_implicitly_constructible<T4> and
                          __is_implicitly_constructible<T5> and
                          __is_implicitly_constructible<T6>))
  tuple()
  requires std::is_default_constructible_v<T0> and
           std::is_default_constructible_v<T1> and
           std::is_default_constructible_v<T2> and
           std::is_default_constructible_v<T3> and
           std::is_default_constructible_v<T4> and
           std::is_default_constructible_v<T5> and
           std::is_default_constructible_v<T6>
  : __x0()
  , __x1()
  , __x2()
  , __x3()
  , __x4()
  , __x5()
  , __x6()
  {}

  constexpr explicit(not (is_convertible_v<T0 const&, T0> and
                          is_convertible_v<T1 const&, T1> and
                          is_convertible_v<T2 const&, T2> and
                          is_convertible_v<T3 const&, T3> and
                          is_convertible_v<T4 const&, T4> and
                          is_convertible_v<T5 const&, T5> and
                          is_convertible_v<T6 const&, T6>))
  tuple(T0 const& t0, T1 const& t1, T2 const& t2, T3 const& t3, T4 const& t4, T5 const& t5, T6 const& t6)
  requires std::is_copy_constructible_v<T0> and
           std::is_copy_constructible_v<T1> and
           std::is_copy_constructible_v<T2> and
           std::is_copy_constructible_v<T3> and
           std::is_copy_constructible_v<T4> and
           std::is_copy_constructible_v<T5> and
           std::is_copy_constructible_v<T6>
  : __x0(t0)
  , __x1(t1)
  , __x2(t2)
  , __x3(t3)
  , __x4(t4)
  , __x5(t5)
  , __x6(t6)
  {}

  template<class U0, class U1, class U2, class U3, class U4, class U5, class U6>
  requires is_constructible_v<T0, U0> and
           is_constructible_v<T1, U1> and
           is_constructible_v<T2, U2> and
           is_constructible_v<T3, U3> and
           is_constructible_v<T4, U4> and
           is_constructible_v<T5, U5> and
           is_constructible_v<T6, U6>
  constexpr explicit(not (is_convertible_v<U0, T0> and
                          is_convertible_v<U1, T1> and
                          is_convertible_v<U2, T2> and
                          is_convertible_v<U3, T3> and
                          is_convertible_v<U4, T4> and
                          is_convertible_v<U5, T5> and
                          is_convertible_v<U6, T6>))
  tuple(U0&& u0, U1&& u1, U2&& u2, U3&& u3, U4&& u4, U5&& u5, U6&& u6)
  : __x0(std::forward<U0>(u0))
  , __x1(std::forward<U1>(u1))
  , __x2(std::forward<U2>(u2))
  , __x3(std::forward<U3>(u3))
  , __x4(std::forward<U4>(u4))
  , __x5(std::forward<U5>(u5))
  , __x6(std::forward<U6>(u6))
  {}

  template<class U0, class U1, class U2, class U3, class U4, class U5, class U6>
  requires is_constructible_v<T0, U0&> and
           is_constructible_v<T1, U1&> and
           is_constructible_v<T2, U2&> and
           is_constructible_v<T3, U3&> and
           is_constructible_v<T4, U4&> and
           is_constructible_v<T5, U5&> and
           is_constructible_v<T6, U6&>
  constexpr explicit(not (is_convertible_v<U0&, T0> and
                          is_convertible_v<U1&, T1> and
                          is_convertible_v<U2&, T2> and
                          is_convertible_v<U3&, T3> and
                          is_convertible_v<U4&, T4> and
                          is_convertible_v<U5&, T5> and
                          is_convertible_v<U6&, T6>))
  tuple(tuple<U0, U1, U2, U3, U4, U5, U6>& t)
  : __x0(std::forward<U0>(t.__x0))
  , __x1(std::forward<U1>(t.__x1))
  , __x2(std::forward<U2>(t.__x2))
  , __x3(std::forward<U3>(t.__x3))
  , __x4(std::forward<U4>(t.__x4))
  , __x5(std::forward<U5>(t.__x5))
  , __x6(std::forward<U6>(t.__x6))
  {}

  template<class U0, class U1, class U2, class U3, class U4, class U5, class U6>
  requires is_constructible_v<T0, U0 const&> and
           is_constructible_v<T1, U1 const&> and
           is_constructible_v<T2, U2 const&> and
           is_constructible_v<T3, U3 const&> and
           is_constructible_v<T4, U4 const&> and
           is_constructible_v<T5, U5 const&> and
           is_constructible_v<T6, U6 const&>
  constexpr explicit(not (is_convertible_v<U0 const&, T0> and
                          is_convertible_v<U1 const&, T1> and
                          is_convertible_v<U2 const&, T2> and
                          is_convertible_v<U3 const&, T3> and
                          is_convertible_v<U4 const&, T4> and
                          is_convertible_v<U5 const&, T5> and
                          is_convertible_v<U6 const&, T6>))
  tuple(tuple<U0, U1, U2, U3, U4, U5, U6> const& t)
  : __x0(std::forward<U0 const>(t.__x0))
  , __x1(std::forward<U1 const>(t.__x1))
  , __x2(std::forward<U2 const>(t.__x2))
  , __x3(std::forward<U3 const>(t.__x3))
  , __x4(std::forward<U4 const>(t.__x4))
  , __x5(std::forward<U5 const>(t.__x5))
  , __x6(std::forward<U6 const>(t.__x6))
  {}

  template<class U0, class U1, class U2, class U3, class U4, class U5, class U6>
  requires is_constructible_v<T0, U0> and
           is_constructible_v<T1, U1> and
           is_constructible_v<T2, U2> and
           is_constructible_v<T3, U3> and
           is_constructible_v<T4, U4> and
           is_constructible_v<T5, U5> and
           is_constructible_v<T6, U6>
  constexpr explicit(not (is_convertible_v<U0, T0> and
                          is_convertible_v<U1, T1> and
                          is_convertible_v<U2, T2> and
                          is_convertible_v<U3, T3> and
                          is_convertible_v<U4, T4> and
                          is_convertible_v<U5, T5> and
                          is_convertible_v<U6, T6>))
  tuple(tuple<U0, U1, U2, U3, U4, U5, U6>&& t)
  : __x0(std::forward<U0>(t.__x0))
  , __x1(std::forward<U1>(t.__x1))
  , __x2(std::forward<U2>(t.__x2))
  , __x3(std::forward<U3>(t.__x3))
  , __x4(std::forward<U4>(t.__x4))
  , __x5(std::forward<U5>(t.__x5))
  , __x6(std::forward<U6>(t.__x6))
  {}

  template<class U0, class U1, class U2, class U3, class U4, class U5, class U6>
  requires is_constructible_v<T0, U0 const> and
           is_constructible_v<T1, U1 const> and
           is_constructible_v<T2, U2 const> and
           is_constructible_v<T3, U3 const> and
           is_constructible_v<T4, U4 const> and
           is_constructible_v<T5, U5 const> and
           is_constructible_v<T6, U6 const>
  constexpr explicit(not (is_convertible_v<U0 const, T0> and
                          is_convertible_v<U1 const, T1> and
                          is_convertible_v<U2 const, T2> and
                          is_convertible_v<U3 const, T3> and
                          is_convertible_v<U4 const, T4> and
                          is_convertible_v<U5 const, T5> and
                          is_convertible_v<U6 const, T6>))
  tuple(tuple<U0, U1, U2, U3, U4, U5, U6> const&& t)
  : __x0(std::forward<U0 const>(t.__x0))
  , __x1(std::forward<U1 const>(t.__x1))
  , __x2(std::forward<U2 const>(t.__x2))
  , __x3(std::forward<U3 const>(t.__x3))
  , __x4(std::forward<U4 const>(t.__x4))
  , __x5(std::forward<U5 const>(t.__x5))
  , __x6(std::forward<U6 const>(t.__x6))
  {}

  template<class Alloc>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&> and
                          __is_implicitly_constructible<T1, Alloc const&> and
                          __is_implicitly_constructible<T2, Alloc const&> and
                          __is_implicitly_constructible<T3, Alloc const&> and
                          __is_implicitly_constructible<T4, Alloc const&> and
                          __is_implicitly_constructible<T5, Alloc const&> and
                          __is_implicitly_constructible<T6, Alloc const&>))
  tuple(allocator_arg_t, Alloc const& a)
  requires std::__constructible_with_allocator<T0, Alloc const&> and
           std::__constructible_with_allocator<T1, Alloc const&> and
           std::__constructible_with_allocator<T2, Alloc const&> and
           std::__constructible_with_allocator<T3, Alloc const&> and
           std::__constructible_with_allocator<T4, Alloc const&> and
           std::__constructible_with_allocator<T5, Alloc const&> and
           std::__constructible_with_allocator<T6, Alloc const&>
  : __x0(__construct_with_allocator<T0>(a))
  , __x1(__construct_with_allocator<T1>(a))
  , __x2(__construct_with_allocator<T2>(a))
  , __x3(__construct_with_allocator<T3>(a))
  , __x4(__construct_with_allocator<T4>(a))
  , __x5(__construct_with_allocator<T5>(a))
  , __x6(__construct_with_allocator<T6>(a))
  {}

  template<class Alloc>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, T0 const&> and
                          __is_implicitly_constructible<T1, Alloc const&, T1 const&> and
                          __is_implicitly_constructible<T2, Alloc const&, T2 const&> and
                          __is_implicitly_constructible<T3, Alloc const&, T3 const&> and
                          __is_implicitly_constructible<T4, Alloc const&, T4 const&> and
                          __is_implicitly_constructible<T5, Alloc const&, T5 const&> and
                          __is_implicitly_constructible<T6, Alloc const&, T6 const&>))
  tuple(allocator_arg_t, Alloc const& alloc, T0 const& t0, T1 const& t1, T2 const& t2, T3 const& t3, T4 const& t4, T5 const& t5, T6 const& t6)
  requires std::__constructible_with_allocator<T0, Alloc const&, T0 const&> and
           std::__constructible_with_allocator<T1, Alloc const&, T1 const&> and
           std::__constructible_with_allocator<T2, Alloc const&, T2 const&> and
           std::__constructible_with_allocator<T3, Alloc const&, T3 const&> and
           std::__constructible_with_allocator<T4, Alloc const&, T4 const&> and
           std::__constructible_with_allocator<T5, Alloc const&, T5 const&> and
           std::__constructible_with_allocator<T6, Alloc const&, T6 const&>
  : __x0(__construct_with_allocator<T0>(alloc, t0))
  , __x1(__construct_with_allocator<T1>(alloc, t1))
  , __x2(__construct_with_allocator<T2>(alloc, t2))
  , __x3(__construct_with_allocator<T3>(alloc, t3))
  , __x4(__construct_with_allocator<T4>(alloc, t4))
  , __x5(__construct_with_allocator<T5>(alloc, t5))
  , __x6(__construct_with_allocator<T6>(alloc, t6))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3, class U4, class U5, class U6>
  requires __constructible_with_allocator<T0, Alloc const&, U0> and
           __constructible_with_allocator<T1, Alloc const&, U1> and
           __constructible_with_allocator<T2, Alloc const&, U2> and
           __constructible_with_allocator<T3, Alloc const&, U3> and
           __constructible_with_allocator<T4, Alloc const&, U4> and
           __constructible_with_allocator<T5, Alloc const&, U5> and
           __constructible_with_allocator<T6, Alloc const&, U6>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0> and
                          __is_implicitly_constructible<T1, Alloc const&, U1> and
                          __is_implicitly_constructible<T2, Alloc const&, U2> and
                          __is_implicitly_constructible<T3, Alloc const&, U3> and
                          __is_implicitly_constructible<T4, Alloc const&, U4> and
                          __is_implicitly_constructible<T5, Alloc const&, U5> and
                          __is_implicitly_constructible<T6, Alloc const&, U6>))
  tuple(allocator_arg_t, Alloc const& alloc, U0&& u0, U1&& u1, U2&& u2, U3&& u3, U4&& u4, U5&& u5, U6&& u6)
  : __x0(__construct_with_allocator<T0>(alloc, std::forward<U0>(u0)))
  , __x1(__construct_with_allocator<T1>(alloc, std::forward<U1>(u1)))
  , __x2(__construct_with_allocator<T2>(alloc, std::forward<U2>(u2)))
  , __x3(__construct_with_allocator<T3>(alloc, std::forward<U3>(u3)))
  , __x4(__construct_with_allocator<T4>(alloc, std::forward<U4>(u4)))
  , __x5(__construct_with_allocator<T5>(alloc, std::forward<U5>(u5)))
  , __x6(__construct_with_allocator<T6>(alloc, std::forward<U6>(u6)))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3, class U4, class U5, class U6>
  requires __constructible_with_allocator<T0, Alloc const&, U0&> and
           __constructible_with_allocator<T1, Alloc const&, U1&> and
           __constructible_with_allocator<T2, Alloc const&, U2&> and
           __constructible_with_allocator<T3, Alloc const&, U3&> and
           __constructible_with_allocator<T4, Alloc const&, U4&> and
           __constructible_with_allocator<T5, Alloc const&, U5&> and
           __constructible_with_allocator<T6, Alloc const&, U6&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0&> and
                          __is_implicitly_constructible<T1, Alloc const&, U1&> and
                          __is_implicitly_constructible<T2, Alloc const&, U2&> and
                          __is_implicitly_constructible<T3, Alloc const&, U3&> and
                          __is_implicitly_constructible<T4, Alloc const&, U4&> and
                          __is_implicitly_constructible<T5, Alloc const&, U5&> and
                          __is_implicitly_constructible<T5, Alloc const&, U6&>))
  tuple(allocator_arg_t, Alloc const& alloc, tuple<U0, U1, U2, U3, U4, U5, U6>& t)
  : __x0(__construct_with_allocator<T0>(alloc, t.__x0))
  , __x1(__construct_with_allocator<T1>(alloc, t.__x1))
  , __x2(__construct_with_allocator<T2>(alloc, t.__x2))
  , __x3(__construct_with_allocator<T3>(alloc, t.__x3))
  , __x4(__construct_with_allocator<T4>(alloc, t.__x4))
  , __x5(__construct_with_allocator<T5>(alloc, t.__x5))
  , __x6(__construct_with_allocator<T6>(alloc, t.__x6))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3, class U4, class U5, class U6>
  requires __constructible_with_allocator<T0, Alloc const&, U0 const&> and
           __constructible_with_allocator<T1, Alloc const&, U1 const&> and
           __constructible_with_allocator<T2, Alloc const&, U2 const&> and
           __constructible_with_allocator<T3, Alloc const&, U3 const&> and
           __constructible_with_allocator<T4, Alloc const&, U4 const&> and
           __constructible_with_allocator<T5, Alloc const&, U5 const&> and
           __constructible_with_allocator<T6, Alloc const&, U6 const&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0 const&> and
                          __is_implicitly_constructible<T1, Alloc const&, U1 const&> and
                          __is_implicitly_constructible<T2, Alloc const&, U2 const&> and
                          __is_implicitly_constructible<T3, Alloc const&, U3 const&> and
                          __is_implicitly_constructible<T4, Alloc const&, U4 const&> and
                          __is_implicitly_constructible<T5, Alloc const&, U5 const&> and
                          __is_implicitly_constructible<T6, Alloc const&, U6 const&>))
  tuple(allocator_arg_t, Alloc const& alloc, tuple<U0, U1, U2, U3, U4, U5, U6> const& t)
  : __x0(__construct_with_allocator<T0>(alloc, t.__x0))
  , __x1(__construct_with_allocator<T1>(alloc, t.__x1))
  , __x2(__construct_with_allocator<T2>(alloc, t.__x2))
  , __x3(__construct_with_allocator<T3>(alloc, t.__x3))
  , __x4(__construct_with_allocator<T4>(alloc, t.__x4))
  , __x5(__construct_with_allocator<T5>(alloc, t.__x5))
  , __x6(__construct_with_allocator<T6>(alloc, t.__x6))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3, class U4, class U5, class U6>
  requires __constructible_with_allocator<T0, Alloc const&, U0&&> and
           __constructible_with_allocator<T1, Alloc const&, U1&&> and
           __constructible_with_allocator<T2, Alloc const&, U2&&> and
           __constructible_with_allocator<T3, Alloc const&, U3&&> and
           __constructible_with_allocator<T4, Alloc const&, U4&&> and
           __constructible_with_allocator<T5, Alloc const&, U5&&> and
           __constructible_with_allocator<T6, Alloc const&, U6&&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0&&> and
                          __is_implicitly_constructible<T1, Alloc const&, U1&&> and
                          __is_implicitly_constructible<T2, Alloc const&, U2&&> and
                          __is_implicitly_constructible<T3, Alloc const&, U3&&> and
                          __is_implicitly_constructible<T4, Alloc const&, U4&&> and
                          __is_implicitly_constructible<T5, Alloc const&, U5&&> and
                          __is_implicitly_constructible<T6, Alloc const&, U6&&>))
  tuple(allocator_arg_t, Alloc const& alloc, tuple<U0, U1, U2, U3, U4, U5, U6>&& t)
  : __x0(__construct_with_allocator<T0>(alloc, std::move(t.__x0)))
  , __x1(__construct_with_allocator<T1>(alloc, std::move(t.__x1)))
  , __x2(__construct_with_allocator<T2>(alloc, std::move(t.__x2)))
  , __x3(__construct_with_allocator<T3>(alloc, std::move(t.__x3)))
  , __x4(__construct_with_allocator<T4>(alloc, std::move(t.__x4)))
  , __x5(__construct_with_allocator<T5>(alloc, std::move(t.__x5)))
  , __x6(__construct_with_allocator<T6>(alloc, std::move(t.__x6)))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3, class U4, class U5, class U6>
  requires __constructible_with_allocator<T0, Alloc const&, U0 const&&> and
           __constructible_with_allocator<T1, Alloc const&, U1 const&&> and
           __constructible_with_allocator<T2, Alloc const&, U2 const&&> and
           __constructible_with_allocator<T3, Alloc const&, U3 const&&> and
           __constructible_with_allocator<T4, Alloc const&, U4 const&&> and
           __constructible_with_allocator<T5, Alloc const&, U5 const&&> and
           __constructible_with_allocator<T6, Alloc const&, U6 const&&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0 const&&> and
                          __is_implicitly_constructible<T1, Alloc const&, U1 const&&> and
                          __is_implicitly_constructible<T2, Alloc const&, U2 const&&> and
                          __is_implicitly_constructible<T3, Alloc const&, U3 const&&> and
                          __is_implicitly_constructible<T4, Alloc const&, U4 const&&> and
                          __is_implicitly_constructible<T5, Alloc const&, U5 const&&> and
                          __is_implicitly_constructible<T6, Alloc const&, U6 const&&>))
  tuple(allocator_arg_t, Alloc const& alloc, tuple<U0, U1, U2, U3, U4, U5, U6> const&& t)
  : __x0(__construct_with_allocator<T0>(alloc, std::move(t.__x0)))
  , __x1(__construct_with_allocator<T1>(alloc, std::move(t.__x1)))
  , __x2(__construct_with_allocator<T2>(alloc, std::move(t.__x2)))
  , __x3(__construct_with_allocator<T3>(alloc, std::move(t.__x3)))
  , __x4(__construct_with_allocator<T4>(alloc, std::move(t.__x4)))
  , __x5(__construct_with_allocator<T5>(alloc, std::move(t.__x5)))
  , __x6(__construct_with_allocator<T6>(alloc, std::move(t.__x6)))
  {}

  // template<class Alloc, tuple-like UTuple>
  // constexpr explicit(see below) tuple(allocator_arg_t, const Alloc& a, UTuple&&);

  tuple(tuple const&) = default;
  tuple(tuple&&) = default;

  // [tuple.assign], tuple assignment
  constexpr tuple& operator=(tuple const&) = default;
  constexpr tuple& operator=(tuple&&) = default;

  constexpr const tuple& operator=(tuple const& other) const
  requires std::is_copy_assignable_v<T0 const> and
           std::is_copy_assignable_v<T1 const> and
           std::is_copy_assignable_v<T2 const> and
           std::is_copy_assignable_v<T3 const> and
           std::is_copy_assignable_v<T4 const> and
           std::is_copy_assignable_v<T5 const> and
           std::is_copy_assignable_v<T6 const>
  {
    [[clang::always_inline]] __x0 = other.__x0;
    [[clang::always_inline]] __x1 = other.__x1;
    [[clang::always_inline]] __x2 = other.__x2;
    [[clang::always_inline]] __x3 = other.__x3;
    [[clang::always_inline]] __x4 = other.__x4;
    [[clang::always_inline]] __x5 = other.__x5;
    [[clang::always_inline]] __x6 = other.__x6;
    return *this;
  }

  constexpr const tuple& operator=(tuple&& other) const
  requires std::is_assignable_v<T0 const&, T0> and
           std::is_assignable_v<T1 const&, T1> and
           std::is_assignable_v<T2 const&, T2> and
           std::is_assignable_v<T3 const&, T3> and
           std::is_assignable_v<T4 const&, T4> and
           std::is_assignable_v<T5 const&, T5> and
           std::is_assignable_v<T6 const&, T6>
  {
    [[clang::always_inline]] swap(std::move(other));
    return *this;
  }

  template<class U0, class U1, class U2, class U3, class U4, class U5, class U6>
  requires std::is_assignable_v<T0&, U0 const&> and
           std::is_assignable_v<T1&, U1 const&> and
           std::is_assignable_v<T2&, U2 const&> and
           std::is_assignable_v<T3&, U3 const&> and
           std::is_assignable_v<T4&, U4 const&> and
           std::is_assignable_v<T5&, U5 const&> and
           std::is_assignable_v<T6&, U6 const&>
  constexpr tuple& operator=(tuple<U0, U1, U2, U3, U4, U5, U6> const& other)
  {
    [[clang::always_inline]] __x0 = other.__x0;
    [[clang::always_inline]] __x1 = other.__x1;
    [[clang::always_inline]] __x2 = other.__x2;
    [[clang::always_inline]] __x3 = other.__x3;
    [[clang::always_inline]] __x4 = other.__x4;
    [[clang::always_inline]] __x5 = other.__x5;
    [[clang::always_inline]] __x6 = other.__x6;
    return *this;
  }

  template<class U0, class U1, class U2, class U3, class U4, class U5, class U6>
  requires std::is_assignable_v<T0 const&, U0 const&> and
           std::is_assignable_v<T1 const&, U1 const&> and
           std::is_assignable_v<T2 const&, U2 const&> and
           std::is_assignable_v<T3 const&, U3 const&> and
           std::is_assignable_v<T4 const&, U4 const&> and
           std::is_assignable_v<T5 const&, U5 const&> and
           std::is_assignable_v<T6 const&, U6 const&>
  constexpr tuple& operator=(tuple<U0, U1, U2, U3, U4, U5, U6> const& other) const
  {
    [[clang::always_inline]] __x0 = other.__x0;
    [[clang::always_inline]] __x1 = other.__x1;
    [[clang::always_inline]] __x2 = other.__x2;
    [[clang::always_inline]] __x3 = other.__x3;
    [[clang::always_inline]] __x4 = other.__x4;
    [[clang::always_inline]] __x5 = other.__x5;
    [[clang::always_inline]] __x6 = other.__x6;
    return *this;
  }

  template<class U0, class U1, class U2, class U3, class U4, class U5, class U6>
  requires std::is_assignable_v<T0&, U0> and
           std::is_assignable_v<T1&, U1> and
           std::is_assignable_v<T2&, U2> and
           std::is_assignable_v<T3&, U3> and
           std::is_assignable_v<T4&, U4> and
           std::is_assignable_v<T5&, U5> and
           std::is_assignable_v<T6&, U6>
  constexpr tuple& operator=(tuple<U0, U1, U2, U3, U4, U5, U6>&& other)
  {
    [[clang::always_inline]] __x0 = std::move(other.__x0);
    [[clang::always_inline]] __x1 = std::move(other.__x1);
    [[clang::always_inline]] __x2 = std::move(other.__x2);
    [[clang::always_inline]] __x3 = std::move(other.__x3);
    [[clang::always_inline]] __x4 = std::move(other.__x4);
    [[clang::always_inline]] __x5 = std::move(other.__x5);
    [[clang::always_inline]] __x6 = std::move(other.__x6);
    return *this;
  }

  template<class U0, class U1, class U2, class U3, class U4, class U5, class U6>
  requires is_assignable_v<T0 const&, U0 const> and
           is_assignable_v<T1 const&, U1 const> and
           is_assignable_v<T2 const&, U2 const> and
           is_assignable_v<T3 const&, U3 const> and
           is_assignable_v<T4 const&, U4 const> and
           is_assignable_v<T5 const&, U5 const> and
           is_assignable_v<T6 const&, U6 const>
  constexpr tuple const& operator=(tuple<U0, U1, U2, U4, U5, U6> const&& other) const
  {
    [[clang::always_inline]] __x0 = std::move(other.__x0);
    [[clang::always_inline]] __x1 = std::move(other.__x1);
    [[clang::always_inline]] __x2 = std::move(other.__x2);
    [[clang::always_inline]] __x3 = std::move(other.__x3);
    [[clang::always_inline]] __x4 = std::move(other.__x4);
    [[clang::always_inline]] __x5 = std::move(other.__x5);
    [[clang::always_inline]] __x6 = std::move(other.__x6);
    return *this;
  }

  // template<tuple-like UTuple>
  // constexpr tuple& operator=(UTuple&&);
  // template<tuple-like UTuple>
  // constexpr const tuple& operator=(UTuple&&) const;

  // [tuple.swap], tuple swap

  constexpr void swap(tuple& other) noexcept(is_nothrow_swappable_v<T0> and
                                             is_nothrow_swappable_v<T1> and
                                             is_nothrow_swappable_v<T2> and
                                             is_nothrow_swappable_v<T3> and
                                             is_nothrow_swappable_v<T4> and
                                             is_nothrow_swappable_v<T5> and
                                             is_nothrow_swappable_v<T6>)
  requires swappable<T0> and
           swappable<T1> and
           swappable<T2> and
           swappable<T3> and
           swappable<T4> and
           swappable<T5> and
           swappable<T6>
  {
    [[clang::always_inline]] std::ranges::swap(__x0, other.__x0);
    [[clang::always_inline]] std::ranges::swap(__x1, other.__x1);
    [[clang::always_inline]] std::ranges::swap(__x2, other.__x2);
    [[clang::always_inline]] std::ranges::swap(__x3, other.__x3);
    [[clang::always_inline]] std::ranges::swap(__x4, other.__x4);
    [[clang::always_inline]] std::ranges::swap(__x5, other.__x5);
    [[clang::always_inline]] std::ranges::swap(__x6, other.__x6);
  }

  constexpr void swap(tuple const& other) const noexcept(is_nothrow_swappable_v<T0 const> and
                                                         is_nothrow_swappable_v<T1 const> and
                                                         is_nothrow_swappable_v<T2 const> and
                                                         is_nothrow_swappable_v<T3 const> and
                                                         is_nothrow_swappable_v<T4 const> and
                                                         is_nothrow_swappable_v<T5 const> and
                                                         is_nothrow_swappable_v<T6 const>)
  requires swappable<T0 const> and
           swappable<T1 const> and
           swappable<T2 const> and
           swappable<T3 const> and
           swappable<T4 const> and
           swappable<T5 const> and
           swappable<T6 const>
  {
    [[clang::always_inline]] std::ranges::swap(__x0, other.__x0);
    [[clang::always_inline]] std::ranges::swap(__x1, other.__x1);
    [[clang::always_inline]] std::ranges::swap(__x2, other.__x2);
    [[clang::always_inline]] std::ranges::swap(__x3, other.__x3);
    [[clang::always_inline]] std::ranges::swap(__x4, other.__x4);
    [[clang::always_inline]] std::ranges::swap(__x5, other.__x5);
    [[clang::always_inline]] std::ranges::swap(__x6, other.__x6);
  }

  template<equality_comparable_with<T0> U0,
           equality_comparable_with<T1> U1,
           equality_comparable_with<T2> U2,
           equality_comparable_with<T3> U3,
           equality_comparable_with<T4> U4,
           equality_comparable_with<T5> U5,
           equality_comparable_with<T6> U6>
  friend constexpr bool operator==(tuple const& t, tuple<U0, U1, U2, U3, U4, U5, U6> const& u)
  {
      return t.__x0 == u.__x0 and
             t.__x1 == u.__x1 and
             t.__x2 == u.__x2 and
             t.__x3 == u.__x3 and
             t.__x4 == u.__x4 and
             t.__x5 == u.__x5 and
             t.__x6 == u.__x6;
  }

  template<__synth_three_way_comparable_with<T0> U0,
           __synth_three_way_comparable_with<T1> U1,
           __synth_three_way_comparable_with<T2> U2,
           __synth_three_way_comparable_with<T3> U3,
           __synth_three_way_comparable_with<T4> U4,
           __synth_three_way_comparable_with<T5> U5,
           __synth_three_way_comparable_with<T6> U6>
  friend constexpr auto operator<=>(tuple const& t, tuple<U0, U1, U2, U3, U4, U5, U6> const& u)
  -> common_comparison_category_t<__synth_three_way_result<T0, U0>,
                                  __synth_three_way_result<T1, U1>,
                                  __synth_three_way_result<T2, U2>,
                                  __synth_three_way_result<T3, U3>,
                                  __synth_three_way_result<T4, U4>,
                                  __synth_three_way_result<T5, U5>,
                                  __synth_three_way_result<T6, U6>>
  {
    if (auto result = __synth_three_way(t.__x0, u.__x0); result != std::partial_ordering::equivalent) {
      return result;
    }

    if (auto result = __synth_three_way(t.__x1, u.__x1); result != std::partial_ordering::equivalent) {
      return result;
    }

    if (auto result = __synth_three_way(t.__x2, u.__x2); result != std::partial_ordering::equivalent) {
      return result;
    }

    if (auto result = __synth_three_way(t.__x3, u.__x3); result != std::partial_ordering::equivalent) {
      return result;
    }

    if (auto result = __synth_three_way(t.__x4, u.__x4); result != std::partial_ordering::equivalent) {
      return result;
    }

    if (auto result = __synth_three_way(t.__x5, u.__x5); result != std::partial_ordering::equivalent) {
      return result;
    }

    return __synth_three_way(t.__x6, u.__x6);
  }
};

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
class _LIBCPP_TEMPLATE_VIS tuple<T0, T1, T2, T3, T4, T5, T6, T7> {
public:
  [[no_unique_address]] T0 __x0;
  [[no_unique_address]] T1 __x1;
  [[no_unique_address]] T2 __x2;
  [[no_unique_address]] T3 __x3;
  [[no_unique_address]] T4 __x4;
  [[no_unique_address]] T5 __x5;
  [[no_unique_address]] T6 __x6;
  [[no_unique_address]] T7 __x7;

  constexpr explicit(not (__is_implicitly_constructible<T0> and
                          __is_implicitly_constructible<T1> and
                          __is_implicitly_constructible<T2> and
                          __is_implicitly_constructible<T3> and
                          __is_implicitly_constructible<T4> and
                          __is_implicitly_constructible<T5> and
                          __is_implicitly_constructible<T6> and
                          __is_implicitly_constructible<T7>))
  tuple()
  requires std::is_default_constructible_v<T0> and
           std::is_default_constructible_v<T1> and
           std::is_default_constructible_v<T2> and
           std::is_default_constructible_v<T3> and
           std::is_default_constructible_v<T4> and
           std::is_default_constructible_v<T5> and
           std::is_default_constructible_v<T6> and
           std::is_default_constructible_v<T7>
  : __x0()
  , __x1()
  , __x2()
  , __x3()
  , __x4()
  , __x5()
  , __x6()
  , __x7()
  {}

  constexpr explicit(not (is_convertible_v<T0 const&, T0> and
                          is_convertible_v<T1 const&, T1> and
                          is_convertible_v<T2 const&, T2> and
                          is_convertible_v<T3 const&, T3> and
                          is_convertible_v<T4 const&, T4> and
                          is_convertible_v<T5 const&, T5> and
                          is_convertible_v<T6 const&, T6> and
                          is_convertible_v<T7 const&, T7>))
  tuple(T0 const& t0, T1 const& t1, T2 const& t2, T3 const& t3, T4 const& t4, T5 const& t5, T6 const& t6, T7 const& t7)
  requires std::is_copy_constructible_v<T0> and
           std::is_copy_constructible_v<T1> and
           std::is_copy_constructible_v<T2> and
           std::is_copy_constructible_v<T3> and
           std::is_copy_constructible_v<T4> and
           std::is_copy_constructible_v<T5> and
           std::is_copy_constructible_v<T6> and
           std::is_copy_constructible_v<T7>
  : __x0(t0)
  , __x1(t1)
  , __x2(t2)
  , __x3(t3)
  , __x4(t4)
  , __x5(t5)
  , __x6(t6)
  , __x7(t7)
  {}

  template<class U0, class U1, class U2, class U3, class U4, class U5, class U6, class U7>
  requires is_constructible_v<T0, U0> and
           is_constructible_v<T1, U1> and
           is_constructible_v<T2, U2> and
           is_constructible_v<T3, U3> and
           is_constructible_v<T4, U4> and
           is_constructible_v<T5, U5> and
           is_constructible_v<T6, U6> and
           is_constructible_v<T7, U7>
  constexpr explicit(not (is_convertible_v<U0, T0> and
                          is_convertible_v<U1, T1> and
                          is_convertible_v<U2, T2> and
                          is_convertible_v<U3, T3> and
                          is_convertible_v<U4, T4> and
                          is_convertible_v<U5, T5> and
                          is_convertible_v<U6, T6> and
                          is_convertible_v<U7, T7>))
  tuple(U0&& u0, U1&& u1, U2&& u2, U3&& u3, U4&& u4, U5&& u5, U6&& u6, U7&& u7)
  : __x0(std::forward<U0>(u0))
  , __x1(std::forward<U1>(u1))
  , __x2(std::forward<U2>(u2))
  , __x3(std::forward<U3>(u3))
  , __x4(std::forward<U4>(u4))
  , __x5(std::forward<U5>(u5))
  , __x6(std::forward<U6>(u6))
  , __x7(std::forward<U7>(u7))
  {}

  template<class U0, class U1, class U2, class U3, class U4, class U5, class U6, class U7>
  requires is_constructible_v<T0, U0&> and
           is_constructible_v<T1, U1&> and
           is_constructible_v<T2, U2&> and
           is_constructible_v<T3, U3&> and
           is_constructible_v<T4, U4&> and
           is_constructible_v<T5, U5&> and
           is_constructible_v<T6, U6&> and
           is_constructible_v<T7, U7&>
  constexpr explicit(not (is_convertible_v<U0&, T0> and
                          is_convertible_v<U1&, T1> and
                          is_convertible_v<U2&, T2> and
                          is_convertible_v<U3&, T3> and
                          is_convertible_v<U4&, T4> and
                          is_convertible_v<U5&, T5> and
                          is_convertible_v<U6&, T6> and
                          is_convertible_v<U7&, T7>))
  tuple(tuple<U0, U1, U2, U3, U4, U5, U6, U7>& t)
  : __x0(std::forward<U0>(t.__x0))
  , __x1(std::forward<U1>(t.__x1))
  , __x2(std::forward<U2>(t.__x2))
  , __x3(std::forward<U3>(t.__x3))
  , __x4(std::forward<U4>(t.__x4))
  , __x5(std::forward<U5>(t.__x5))
  , __x6(std::forward<U6>(t.__x6))
  , __x7(std::forward<U7>(t.__x7))
  {}

  template<class U0, class U1, class U2, class U3, class U4, class U5, class U6, class U7>
  requires is_constructible_v<T0, U0 const&> and
           is_constructible_v<T1, U1 const&> and
           is_constructible_v<T2, U2 const&> and
           is_constructible_v<T3, U3 const&> and
           is_constructible_v<T4, U4 const&> and
           is_constructible_v<T5, U5 const&> and
           is_constructible_v<T6, U6 const&> and
           is_constructible_v<T7, U7 const&>
  constexpr explicit(not (is_convertible_v<U0 const&, T0> and
                          is_convertible_v<U1 const&, T1> and
                          is_convertible_v<U2 const&, T2> and
                          is_convertible_v<U3 const&, T3> and
                          is_convertible_v<U4 const&, T4> and
                          is_convertible_v<U5 const&, T5> and
                          is_convertible_v<U6 const&, T6> and
                          is_convertible_v<U7 const&, T7>))
  tuple(tuple<U0, U1, U2, U3, U4, U5, U6, U7> const& t)
  : __x0(std::forward<U0 const>(t.__x0))
  , __x1(std::forward<U1 const>(t.__x1))
  , __x2(std::forward<U2 const>(t.__x2))
  , __x3(std::forward<U3 const>(t.__x3))
  , __x4(std::forward<U4 const>(t.__x4))
  , __x5(std::forward<U5 const>(t.__x5))
  , __x6(std::forward<U6 const>(t.__x6))
  , __x7(std::forward<U7 const>(t.__x7))
  {}

  template<class U0, class U1, class U2, class U3, class U4, class U5, class U6, class U7>
  requires is_constructible_v<T0, U0> and
           is_constructible_v<T1, U1> and
           is_constructible_v<T2, U2> and
           is_constructible_v<T3, U3> and
           is_constructible_v<T4, U4> and
           is_constructible_v<T5, U5> and
           is_constructible_v<T6, U6> and
           is_constructible_v<T7, U7>
  constexpr explicit(not (is_convertible_v<U0, T0> and
                          is_convertible_v<U1, T1> and
                          is_convertible_v<U2, T2> and
                          is_convertible_v<U3, T3> and
                          is_convertible_v<U4, T4> and
                          is_convertible_v<U5, T5> and
                          is_convertible_v<U6, T6> and
                          is_convertible_v<U7, T7>))
  tuple(tuple<U0, U1, U2, U3, U4, U5, U6, U7>&& t)
  : __x0(std::forward<U0>(t.__x0))
  , __x1(std::forward<U1>(t.__x1))
  , __x2(std::forward<U2>(t.__x2))
  , __x3(std::forward<U3>(t.__x3))
  , __x4(std::forward<U4>(t.__x4))
  , __x5(std::forward<U5>(t.__x5))
  , __x6(std::forward<U6>(t.__x6))
  , __x7(std::forward<U7>(t.__x7))
  {}

  template<class U0, class U1, class U2, class U3, class U4, class U5, class U6, class U7>
  requires is_constructible_v<T0, U0 const> and
           is_constructible_v<T1, U1 const> and
           is_constructible_v<T2, U2 const> and
           is_constructible_v<T3, U3 const> and
           is_constructible_v<T4, U4 const> and
           is_constructible_v<T5, U5 const> and
           is_constructible_v<T6, U6 const> and
           is_constructible_v<T7, U7 const>
  constexpr explicit(not (is_convertible_v<U0 const, T0> and
                          is_convertible_v<U1 const, T1> and
                          is_convertible_v<U2 const, T2> and
                          is_convertible_v<U3 const, T3> and
                          is_convertible_v<U4 const, T4> and
                          is_convertible_v<U5 const, T5> and
                          is_convertible_v<U6 const, T6> and
                          is_convertible_v<U7 const, T7>))
  tuple(tuple<U0, U1, U2, U3, U4, U5, U6, U7> const&& t)
  : __x0(std::forward<U0 const>(t.__x0))
  , __x1(std::forward<U1 const>(t.__x1))
  , __x2(std::forward<U2 const>(t.__x2))
  , __x3(std::forward<U3 const>(t.__x3))
  , __x4(std::forward<U4 const>(t.__x4))
  , __x5(std::forward<U5 const>(t.__x5))
  , __x6(std::forward<U6 const>(t.__x6))
  , __x7(std::forward<U7 const>(t.__x7))
  {}

  template<class Alloc>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&> and
                          __is_implicitly_constructible<T1, Alloc const&> and
                          __is_implicitly_constructible<T2, Alloc const&> and
                          __is_implicitly_constructible<T3, Alloc const&> and
                          __is_implicitly_constructible<T4, Alloc const&> and
                          __is_implicitly_constructible<T5, Alloc const&> and
                          __is_implicitly_constructible<T6, Alloc const&> and
                          __is_implicitly_constructible<T7, Alloc const&>))
  tuple(allocator_arg_t, Alloc const& a)
  requires __constructible_with_allocator<T0, Alloc const&> and
           __constructible_with_allocator<T1, Alloc const&> and
           __constructible_with_allocator<T2, Alloc const&> and
           __constructible_with_allocator<T3, Alloc const&> and
           __constructible_with_allocator<T4, Alloc const&> and
           __constructible_with_allocator<T5, Alloc const&> and
           __constructible_with_allocator<T6, Alloc const&> and
           __constructible_with_allocator<T7, Alloc const&>
  : __x0(__construct_with_allocator<T0>(a))
  , __x1(__construct_with_allocator<T1>(a))
  , __x2(__construct_with_allocator<T2>(a))
  , __x3(__construct_with_allocator<T3>(a))
  , __x4(__construct_with_allocator<T4>(a))
  , __x5(__construct_with_allocator<T5>(a))
  , __x6(__construct_with_allocator<T6>(a))
  , __x7(__construct_with_allocator<T7>(a))
  {}

  template<class Alloc>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, T0 const&> and
                          __is_implicitly_constructible<T1, Alloc const&, T1 const&> and
                          __is_implicitly_constructible<T2, Alloc const&, T2 const&> and
                          __is_implicitly_constructible<T3, Alloc const&, T3 const&> and
                          __is_implicitly_constructible<T4, Alloc const&, T4 const&> and
                          __is_implicitly_constructible<T5, Alloc const&, T5 const&> and
                          __is_implicitly_constructible<T6, Alloc const&, T6 const&> and
                          __is_implicitly_constructible<T7, Alloc const&, T7 const&>))
  tuple(allocator_arg_t, Alloc const& alloc, T0 const& t0, T1 const& t1, T2 const& t2, T3 const& t3, T4 const& t4, T5 const& t5, T6 const& t6, T7 const& t7)
  requires __constructible_with_allocator<T0, Alloc const&, T0 const&> and
           __constructible_with_allocator<T1, Alloc const&, T1 const&> and
           __constructible_with_allocator<T2, Alloc const&, T2 const&> and
           __constructible_with_allocator<T3, Alloc const&, T3 const&> and
           __constructible_with_allocator<T4, Alloc const&, T4 const&> and
           __constructible_with_allocator<T5, Alloc const&, T5 const&> and
           __constructible_with_allocator<T6, Alloc const&, T6 const&> and
           __constructible_with_allocator<T7, Alloc const&, T7 const&>
  : __x0(__construct_with_allocator<T0>(alloc, t0))
  , __x1(__construct_with_allocator<T1>(alloc, t1))
  , __x2(__construct_with_allocator<T2>(alloc, t2))
  , __x3(__construct_with_allocator<T3>(alloc, t3))
  , __x4(__construct_with_allocator<T4>(alloc, t4))
  , __x5(__construct_with_allocator<T5>(alloc, t5))
  , __x6(__construct_with_allocator<T6>(alloc, t6))
  , __x7(__construct_with_allocator<T7>(alloc, t7))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3, class U4, class U5, class U6, class U7>
  requires __constructible_with_allocator<T0, Alloc const&, U0> and
           __constructible_with_allocator<T1, Alloc const&, U1> and
           __constructible_with_allocator<T2, Alloc const&, U2> and
           __constructible_with_allocator<T3, Alloc const&, U3> and
           __constructible_with_allocator<T4, Alloc const&, U4> and
           __constructible_with_allocator<T5, Alloc const&, U5> and
           __constructible_with_allocator<T6, Alloc const&, U6> and
           __constructible_with_allocator<T7, Alloc const&, U7>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0> and
                          __is_implicitly_constructible<T1, Alloc const&, U1> and
                          __is_implicitly_constructible<T2, Alloc const&, U2> and
                          __is_implicitly_constructible<T3, Alloc const&, U3> and
                          __is_implicitly_constructible<T4, Alloc const&, U4> and
                          __is_implicitly_constructible<T5, Alloc const&, U5> and
                          __is_implicitly_constructible<T6, Alloc const&, U6> and
                          __is_implicitly_constructible<T7, Alloc const&, U7>))
  tuple(allocator_arg_t, Alloc const& alloc, U0&& u0, U1&& u1, U2&& u2, U3&& u3, U4&& u4, U5&& u5, U6&& u6, U7&& u7)
  : __x0(__construct_with_allocator<T0>(alloc, std::forward<U0>(u0)))
  , __x1(__construct_with_allocator<T1>(alloc, std::forward<U1>(u1)))
  , __x2(__construct_with_allocator<T2>(alloc, std::forward<U2>(u2)))
  , __x3(__construct_with_allocator<T3>(alloc, std::forward<U3>(u3)))
  , __x4(__construct_with_allocator<T4>(alloc, std::forward<U4>(u4)))
  , __x5(__construct_with_allocator<T5>(alloc, std::forward<U5>(u5)))
  , __x6(__construct_with_allocator<T6>(alloc, std::forward<U6>(u6)))
  , __x7(__construct_with_allocator<T7>(alloc, std::forward<U7>(u7)))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3, class U4, class U5, class U6, class U7>
  requires __constructible_with_allocator<T0, Alloc const&, U0&> and
           __constructible_with_allocator<T1, Alloc const&, U1&> and
           __constructible_with_allocator<T2, Alloc const&, U2&> and
           __constructible_with_allocator<T3, Alloc const&, U3&> and
           __constructible_with_allocator<T4, Alloc const&, U4&> and
           __constructible_with_allocator<T5, Alloc const&, U5&> and
           __constructible_with_allocator<T6, Alloc const&, U6&> and
           __constructible_with_allocator<T7, Alloc const&, U7&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0&> and
                          __is_implicitly_constructible<T1, Alloc const&, U1&> and
                          __is_implicitly_constructible<T2, Alloc const&, U2&> and
                          __is_implicitly_constructible<T3, Alloc const&, U3&> and
                          __is_implicitly_constructible<T4, Alloc const&, U4&> and
                          __is_implicitly_constructible<T5, Alloc const&, U5&> and
                          __is_implicitly_constructible<T6, Alloc const&, U6&> and
                          __is_implicitly_constructible<T7, Alloc const&, U7&>))
  tuple(allocator_arg_t, Alloc const& alloc, tuple<U0, U1, U2, U3, U4, U5, U6>& t)
  : __x0(__construct_with_allocator<T0>(alloc, t.__x0))
  , __x1(__construct_with_allocator<T1>(alloc, t.__x1))
  , __x2(__construct_with_allocator<T2>(alloc, t.__x2))
  , __x3(__construct_with_allocator<T3>(alloc, t.__x3))
  , __x4(__construct_with_allocator<T4>(alloc, t.__x4))
  , __x5(__construct_with_allocator<T5>(alloc, t.__x5))
  , __x6(__construct_with_allocator<T6>(alloc, t.__x6))
  , __x7(__construct_with_allocator<T7>(alloc, t.__x7))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3, class U4, class U5, class U6, class U7>
  requires __constructible_with_allocator<T0, Alloc const&, U0 const&> and
           __constructible_with_allocator<T1, Alloc const&, U1 const&> and
           __constructible_with_allocator<T2, Alloc const&, U2 const&> and
           __constructible_with_allocator<T3, Alloc const&, U3 const&> and
           __constructible_with_allocator<T4, Alloc const&, U4 const&> and
           __constructible_with_allocator<T5, Alloc const&, U5 const&> and
           __constructible_with_allocator<T6, Alloc const&, U6 const&> and
           __constructible_with_allocator<T7, Alloc const&, U7 const&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0 const&> and
                          __is_implicitly_constructible<T1, Alloc const&, U1 const&> and
                          __is_implicitly_constructible<T2, Alloc const&, U2 const&> and
                          __is_implicitly_constructible<T3, Alloc const&, U3 const&> and
                          __is_implicitly_constructible<T4, Alloc const&, U4 const&> and
                          __is_implicitly_constructible<T5, Alloc const&, U5 const&> and
                          __is_implicitly_constructible<T6, Alloc const&, U6 const&> and
                          __is_implicitly_constructible<T7, Alloc const&, U7 const&>))
  tuple(allocator_arg_t, Alloc const& alloc, tuple<U0, U1, U2, U3, U4, U5, U6, U7> const& t)
  : __x0(__construct_with_allocator<T0>(alloc, t.__x0))
  , __x1(__construct_with_allocator<T1>(alloc, t.__x1))
  , __x2(__construct_with_allocator<T2>(alloc, t.__x2))
  , __x3(__construct_with_allocator<T3>(alloc, t.__x3))
  , __x4(__construct_with_allocator<T4>(alloc, t.__x4))
  , __x5(__construct_with_allocator<T5>(alloc, t.__x5))
  , __x6(__construct_with_allocator<T6>(alloc, t.__x6))
  , __x7(__construct_with_allocator<T7>(alloc, t.__x7))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3, class U4, class U5, class U6, class U7>
  requires __constructible_with_allocator<T0, Alloc const&, U0&&> and
           __constructible_with_allocator<T1, Alloc const&, U1&&> and
           __constructible_with_allocator<T2, Alloc const&, U2&&> and
           __constructible_with_allocator<T3, Alloc const&, U3&&> and
           __constructible_with_allocator<T4, Alloc const&, U4&&> and
           __constructible_with_allocator<T5, Alloc const&, U5&&> and
           __constructible_with_allocator<T6, Alloc const&, U6&&> and
           __constructible_with_allocator<T7, Alloc const&, U7&&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0&&> and
                          __is_implicitly_constructible<T1, Alloc const&, U1&&> and
                          __is_implicitly_constructible<T2, Alloc const&, U2&&> and
                          __is_implicitly_constructible<T3, Alloc const&, U3&&> and
                          __is_implicitly_constructible<T4, Alloc const&, U4&&> and
                          __is_implicitly_constructible<T5, Alloc const&, U5&&> and
                          __is_implicitly_constructible<T6, Alloc const&, U6&&> and
                          __is_implicitly_constructible<T7, Alloc const&, U7&&>))
  tuple(allocator_arg_t, Alloc const& alloc, tuple<U0, U1, U2, U3, U4, U5, U6, U7>&& t)
  : __x0(__construct_with_allocator<T0>(alloc, std::move(t.__x0)))
  , __x1(__construct_with_allocator<T1>(alloc, std::move(t.__x1)))
  , __x2(__construct_with_allocator<T2>(alloc, std::move(t.__x2)))
  , __x3(__construct_with_allocator<T3>(alloc, std::move(t.__x3)))
  , __x4(__construct_with_allocator<T4>(alloc, std::move(t.__x4)))
  , __x5(__construct_with_allocator<T5>(alloc, std::move(t.__x5)))
  , __x6(__construct_with_allocator<T6>(alloc, std::move(t.__x6)))
  , __x7(__construct_with_allocator<T7>(alloc, std::move(t.__x7)))
  {}

  template<class Alloc, class U0, class U1, class U2, class U3, class U4, class U5, class U6, class U7>
  requires __constructible_with_allocator<T0, Alloc const&, U0 const&&> and
           __constructible_with_allocator<T1, Alloc const&, U1 const&&> and
           __constructible_with_allocator<T2, Alloc const&, U2 const&&> and
           __constructible_with_allocator<T3, Alloc const&, U3 const&&> and
           __constructible_with_allocator<T4, Alloc const&, U4 const&&> and
           __constructible_with_allocator<T5, Alloc const&, U5 const&&> and
           __constructible_with_allocator<T6, Alloc const&, U6 const&&> and
           __constructible_with_allocator<T7, Alloc const&, U7 const&&>
  constexpr explicit(not (__is_implicitly_constructible<T0, Alloc const&, U0 const&&> and
                          __is_implicitly_constructible<T1, Alloc const&, U1 const&&> and
                          __is_implicitly_constructible<T2, Alloc const&, U2 const&&> and
                          __is_implicitly_constructible<T3, Alloc const&, U3 const&&> and
                          __is_implicitly_constructible<T4, Alloc const&, U4 const&&> and
                          __is_implicitly_constructible<T5, Alloc const&, U5 const&&> and
                          __is_implicitly_constructible<T6, Alloc const&, U6 const&&> and
                          __is_implicitly_constructible<T7, Alloc const&, U7 const&&>))
  tuple(allocator_arg_t, Alloc const& alloc, tuple<U0, U1, U2, U3, U4, U5, U6, U7> const&& t)
  : __x0(__construct_with_allocator<T0>(alloc, std::move(t.__x0)))
  , __x1(__construct_with_allocator<T1>(alloc, std::move(t.__x1)))
  , __x2(__construct_with_allocator<T2>(alloc, std::move(t.__x2)))
  , __x3(__construct_with_allocator<T3>(alloc, std::move(t.__x3)))
  , __x4(__construct_with_allocator<T4>(alloc, std::move(t.__x4)))
  , __x5(__construct_with_allocator<T5>(alloc, std::move(t.__x5)))
  , __x6(__construct_with_allocator<T6>(alloc, std::move(t.__x6)))
  , __x7(__construct_with_allocator<T7>(alloc, std::move(t.__x7)))
  {}

  // template<class Alloc, tuple-like UTuple>
  // constexpr explicit(see below) tuple(allocator_arg_t, const Alloc& a, UTuple&&);

  tuple(tuple const&) = default;
  tuple(tuple&&) = default;

  // [tuple.assign], tuple assignment
  constexpr tuple& operator=(tuple const&) = default;
  constexpr tuple& operator=(tuple&&) = default;

  constexpr const tuple& operator=(tuple const& other) const
  requires std::is_copy_assignable_v<T0 const> and
           std::is_copy_assignable_v<T1 const> and
           std::is_copy_assignable_v<T2 const> and
           std::is_copy_assignable_v<T3 const> and
           std::is_copy_assignable_v<T4 const> and
           std::is_copy_assignable_v<T5 const> and
           std::is_copy_assignable_v<T6 const> and
           std::is_copy_assignable_v<T7 const>
  {
    [[clang::always_inline]] __x0 = other.__x0;
    [[clang::always_inline]] __x1 = other.__x1;
    [[clang::always_inline]] __x2 = other.__x2;
    [[clang::always_inline]] __x3 = other.__x3;
    [[clang::always_inline]] __x4 = other.__x4;
    [[clang::always_inline]] __x5 = other.__x5;
    [[clang::always_inline]] __x6 = other.__x6;
    [[clang::always_inline]] __x7 = other.__x7;
    return *this;
  }

  constexpr const tuple& operator=(tuple&& other) const
  requires std::is_assignable_v<T0 const&, T0> and
           std::is_assignable_v<T1 const&, T1> and
           std::is_assignable_v<T2 const&, T2> and
           std::is_assignable_v<T3 const&, T3> and
           std::is_assignable_v<T4 const&, T4> and
           std::is_assignable_v<T5 const&, T5> and
           std::is_assignable_v<T6 const&, T6> and
           std::is_assignable_v<T7 const&, T7>
  {
    [[clang::always_inline]] swap(std::move(other));
    return *this;
  }

  template<class U0, class U1, class U2, class U3, class U4, class U5, class U6, class U7>
  requires std::is_assignable_v<T0&, U0 const&> and
           std::is_assignable_v<T1&, U1 const&> and
           std::is_assignable_v<T2&, U2 const&> and
           std::is_assignable_v<T3&, U3 const&> and
           std::is_assignable_v<T4&, U4 const&> and
           std::is_assignable_v<T5&, U5 const&> and
           std::is_assignable_v<T6&, U6 const&> and
           std::is_assignable_v<T7&, U7 const&>
  constexpr tuple& operator=(tuple<U0, U1, U2, U3, U4, U5, U6, U7> const& other)
  {
    [[clang::always_inline]] __x0 = other.__x0;
    [[clang::always_inline]] __x1 = other.__x1;
    [[clang::always_inline]] __x2 = other.__x2;
    [[clang::always_inline]] __x3 = other.__x3;
    [[clang::always_inline]] __x4 = other.__x4;
    [[clang::always_inline]] __x5 = other.__x5;
    [[clang::always_inline]] __x6 = other.__x6;
    [[clang::always_inline]] __x7 = other.__x7;
    return *this;
  }

  template<class U0, class U1, class U2, class U3, class U4, class U5, class U6, class U7>
  requires std::is_assignable_v<T0 const&, U0 const&> and
           std::is_assignable_v<T1 const&, U1 const&> and
           std::is_assignable_v<T2 const&, U2 const&> and
           std::is_assignable_v<T3 const&, U3 const&> and
           std::is_assignable_v<T4 const&, U4 const&> and
           std::is_assignable_v<T5 const&, U5 const&> and
           std::is_assignable_v<T6 const&, U6 const&> and
           std::is_assignable_v<T7 const&, U7 const&>
  constexpr tuple& operator=(tuple<U0, U1, U2, U3, U4, U5, U6, U7> const& other) const
  {
    [[clang::always_inline]] __x0 = other.__x0;
    [[clang::always_inline]] __x1 = other.__x1;
    [[clang::always_inline]] __x2 = other.__x2;
    [[clang::always_inline]] __x3 = other.__x3;
    [[clang::always_inline]] __x4 = other.__x4;
    [[clang::always_inline]] __x5 = other.__x5;
    [[clang::always_inline]] __x6 = other.__x6;
    [[clang::always_inline]] __x7 = other.__x7;
    return *this;
  }

  template<class U0, class U1, class U2, class U3, class U4, class U5, class U6, class U7>
  requires std::is_assignable_v<T0&, U0> and
           std::is_assignable_v<T1&, U1> and
           std::is_assignable_v<T2&, U2> and
           std::is_assignable_v<T3&, U3> and
           std::is_assignable_v<T4&, U4> and
           std::is_assignable_v<T5&, U5> and
           std::is_assignable_v<T6&, U6> and
           std::is_assignable_v<T7&, U7>
  constexpr tuple& operator=(tuple<U0, U1, U2, U3, U4, U5, U6, U7>&& other)
  {
    [[clang::always_inline]] __x0 = std::move(other.__x0);
    [[clang::always_inline]] __x1 = std::move(other.__x1);
    [[clang::always_inline]] __x2 = std::move(other.__x2);
    [[clang::always_inline]] __x3 = std::move(other.__x3);
    [[clang::always_inline]] __x4 = std::move(other.__x4);
    [[clang::always_inline]] __x5 = std::move(other.__x5);
    [[clang::always_inline]] __x6 = std::move(other.__x6);
    [[clang::always_inline]] __x7 = std::move(other.__x7);
    return *this;
  }

  template<class U0, class U1, class U2, class U3, class U4, class U5, class U6, class U7>
  requires is_assignable_v<T0 const&, U0 const> and
           is_assignable_v<T1 const&, U1 const> and
           is_assignable_v<T2 const&, U2 const> and
           is_assignable_v<T3 const&, U3 const> and
           is_assignable_v<T4 const&, U4 const> and
           is_assignable_v<T5 const&, U5 const> and
           is_assignable_v<T6 const&, U6 const> and
           is_assignable_v<T7 const&, U7 const>
  constexpr tuple const& operator=(tuple<U0, U1, U2, U4, U5, U6, U7> const&& other) const
  {
    [[clang::always_inline]] __x0 = std::move(other.__x0);
    [[clang::always_inline]] __x1 = std::move(other.__x1);
    [[clang::always_inline]] __x2 = std::move(other.__x2);
    [[clang::always_inline]] __x3 = std::move(other.__x3);
    [[clang::always_inline]] __x4 = std::move(other.__x4);
    [[clang::always_inline]] __x5 = std::move(other.__x5);
    [[clang::always_inline]] __x6 = std::move(other.__x6);
    [[clang::always_inline]] __x7 = std::move(other.__x7);
    return *this;
  }

  // template<tuple-like UTuple>
  // constexpr tuple& operator=(UTuple&&);
  // template<tuple-like UTuple>
  // constexpr const tuple& operator=(UTuple&&) const;

  // [tuple.swap], tuple swap

  constexpr void swap(tuple& other) noexcept(is_nothrow_swappable_v<T0> and
                                             is_nothrow_swappable_v<T1> and
                                             is_nothrow_swappable_v<T2> and
                                             is_nothrow_swappable_v<T3> and
                                             is_nothrow_swappable_v<T4> and
                                             is_nothrow_swappable_v<T5> and
                                             is_nothrow_swappable_v<T6> and
                                             is_nothrow_swappable_v<T7>)
  requires swappable<T0> and
           swappable<T1> and
           swappable<T2> and
           swappable<T3> and
           swappable<T4> and
           swappable<T5> and
           swappable<T6> and
           swappable<T7>
  {
    [[clang::always_inline]] std::ranges::swap(__x0, other.__x0);
    [[clang::always_inline]] std::ranges::swap(__x1, other.__x1);
    [[clang::always_inline]] std::ranges::swap(__x2, other.__x2);
    [[clang::always_inline]] std::ranges::swap(__x3, other.__x3);
    [[clang::always_inline]] std::ranges::swap(__x4, other.__x4);
    [[clang::always_inline]] std::ranges::swap(__x5, other.__x5);
    [[clang::always_inline]] std::ranges::swap(__x6, other.__x6);
    [[clang::always_inline]] std::ranges::swap(__x7, other.__x7);
  }

  constexpr void swap(tuple const& other) const noexcept(is_nothrow_swappable_v<T0 const> and
                                                         is_nothrow_swappable_v<T1 const> and
                                                         is_nothrow_swappable_v<T2 const> and
                                                         is_nothrow_swappable_v<T3 const> and
                                                         is_nothrow_swappable_v<T4 const> and
                                                         is_nothrow_swappable_v<T5 const> and
                                                         is_nothrow_swappable_v<T6 const> and
                                                         is_nothrow_swappable_v<T7 const>)
  requires swappable<T0 const> and
           swappable<T1 const> and
           swappable<T2 const> and
           swappable<T3 const> and
           swappable<T4 const> and
           swappable<T5 const> and
           swappable<T6 const> and
           swappable<T7 const>
  {
    [[clang::always_inline]] std::ranges::swap(__x0, other.__x0);
    [[clang::always_inline]] std::ranges::swap(__x1, other.__x1);
    [[clang::always_inline]] std::ranges::swap(__x2, other.__x2);
    [[clang::always_inline]] std::ranges::swap(__x3, other.__x3);
    [[clang::always_inline]] std::ranges::swap(__x4, other.__x4);
    [[clang::always_inline]] std::ranges::swap(__x5, other.__x5);
    [[clang::always_inline]] std::ranges::swap(__x6, other.__x6);
    [[clang::always_inline]] std::ranges::swap(__x7, other.__x7);
  }

  template<equality_comparable_with<T0> U0,
           equality_comparable_with<T1> U1,
           equality_comparable_with<T2> U2,
           equality_comparable_with<T3> U3,
           equality_comparable_with<T4> U4,
           equality_comparable_with<T5> U5,
           equality_comparable_with<T6> U6,
           equality_comparable_with<T7> U7>
  friend constexpr bool operator==(tuple const& t, tuple<U0, U1, U2, U3, U4, U5, U6, U7> const& u)
  {
      return t.__x0 == u.__x0 and
             t.__x1 == u.__x1 and
             t.__x2 == u.__x2 and
             t.__x3 == u.__x3 and
             t.__x4 == u.__x4 and
             t.__x5 == u.__x5 and
             t.__x6 == u.__x6 and
             t.__x7 == u.__x7;
  }

  template<__synth_three_way_comparable_with<T0> U0,
           __synth_three_way_comparable_with<T1> U1,
           __synth_three_way_comparable_with<T2> U2,
           __synth_three_way_comparable_with<T3> U3,
           __synth_three_way_comparable_with<T4> U4,
           __synth_three_way_comparable_with<T5> U5,
           __synth_three_way_comparable_with<T6> U6,
           __synth_three_way_comparable_with<T7> U7>
  friend constexpr auto operator<=>(tuple const& t, tuple<U0, U1, U2, U3, U4, U5, U6, U7> const& u)
  -> common_comparison_category_t<__synth_three_way_result<T0, U0>,
                                  __synth_three_way_result<T1, U1>,
                                  __synth_three_way_result<T2, U2>,
                                  __synth_three_way_result<T3, U3>,
                                  __synth_three_way_result<T4, U4>,
                                  __synth_three_way_result<T5, U5>,
                                  __synth_three_way_result<T6, U6>,
                                  __synth_three_way_result<T7, U7>>
  {
    if (auto result = __synth_three_way(t.__x0, u.__x0); result != std::partial_ordering::equivalent) {
      return result;
    }

    if (auto result = __synth_three_way(t.__x1, u.__x1); result != std::partial_ordering::equivalent) {
      return result;
    }

    if (auto result = __synth_three_way(t.__x2, u.__x2); result != std::partial_ordering::equivalent) {
      return result;
    }

    if (auto result = __synth_three_way(t.__x3, u.__x3); result != std::partial_ordering::equivalent) {
      return result;
    }

    if (auto result = __synth_three_way(t.__x4, u.__x4); result != std::partial_ordering::equivalent) {
      return result;
    }

    if (auto result = __synth_three_way(t.__x5, u.__x5); result != std::partial_ordering::equivalent) {
      return result;
    }

    if (auto result = __synth_three_way(t.__x6, u.__x6); result != std::partial_ordering::equivalent) {
      return result;
    }

    return __synth_three_way(t.__x7, u.__x7);
  }
};
*/
template<size_t I, class... Ts>
requires (I < sizeof...(Ts))
constexpr tuple_element_t<I, tuple<Ts...>>& get(tuple<Ts...>& t) noexcept
{
  if constexpr (I == 0) {
    return t.__x0;
  }
  else if constexpr (I == 1) {
    return t.__x1;
  }
  else if constexpr (I == 2) {
    return t.__x2;
  }
  else if constexpr (I == 3) {
    return t.__x3;
  }
  else if constexpr (I == 4) {
    return t.__x4;
  }
  else if constexpr (I == 5) {
    return t.__x5;
  }
  else if constexpr (I == 6) {
    return t.__x6;
  }
  else if constexpr (I == 7) {
    return t.__x7;
  }
  else if constexpr (I == 8) {
    return t.__x8;
  }
  else if constexpr (I == 9) {
    return t.__x9;
  }
  else {
    static_assert(&t == nullptr);
  }
}

template<size_t I, class... Ts>
requires (I < sizeof...(Ts))
constexpr tuple_element_t<I, tuple<Ts...>> const& get(tuple<Ts...> const& t) noexcept
{
  if constexpr (I == 0) {
    return t.__x0;
  }
  else if constexpr (I == 1) {
    return t.__x1;
  }
  else if constexpr (I == 2) {
    return t.__x2;
  }
  else if constexpr (I == 3) {
    return t.__x3;
  }
  else if constexpr (I == 4) {
    return t.__x4;
  }
  else if constexpr (I == 5) {
    return t.__x5;
  }
  else if constexpr (I == 6) {
    return t.__x6;
  }
  else if constexpr (I == 7) {
    return t.__x7;
  }
  else if constexpr (I == 8) {
    return t.__x8;
  }
  else if constexpr (I == 9) {
    return t.__x9;
  }
  else {
    static_assert(&t == nullptr);
  }
}

template<size_t I, class... Ts>
requires (I < sizeof...(Ts))
constexpr tuple_element_t<I, tuple<Ts...>>&& get(tuple<Ts...>&& t) noexcept
{
  if constexpr (I == 0) {
    return std::forward<tuple_element_t<I, tuple<Ts...>>>(t.__x0);
  }
  else if constexpr (I == 1) {
    return std::forward<tuple_element_t<I, tuple<Ts...>>>(t.__x1);
  }
  else if constexpr (I == 2) {
    return std::forward<tuple_element_t<I, tuple<Ts...>>>(t.__x2);
  }
  else if constexpr (I == 3) {
    return std::forward<tuple_element_t<I, tuple<Ts...>>>(t.__x3);
  }
  else if constexpr (I == 4) {
    return std::forward<tuple_element_t<I, tuple<Ts...>>>(t.__x4);
  }
  else if constexpr (I == 5) {
    return std::forward<tuple_element_t<I, tuple<Ts...>>>(t.__x5);
  }
  else if constexpr (I == 6) {
    return std::forward<tuple_element_t<I, tuple<Ts...>>>(t.__x6);
  }
  else if constexpr (I == 7) {
    return std::forward<tuple_element_t<I, tuple<Ts...>>>(t.__x7);
  }
  else if constexpr (I == 8) {
    return std::forward<tuple_element_t<I, tuple<Ts...>>>(t.__x8);
  }
  else if constexpr (I == 9) {
    return std::forward<tuple_element_t<I, tuple<Ts...>>>(t.__x9);
  }
  else {
    static_assert(&t == nullptr);
  }
}

template<size_t I, class... Ts>
requires (I < sizeof...(Ts))
constexpr tuple_element_t<I, tuple<Ts...>> const&& get(tuple<Ts...> const&& t) noexcept
{
  if constexpr (I == 0) {
    return std::move(t.__x0);
  }
  else if constexpr (I == 1) {
    return std::move(t.__x1);
  }
  else if constexpr (I == 2) {
    return std::move(t.__x2);
  }
  else if constexpr (I == 3) {
    return std::move(t.__x3);
  }
  else if constexpr (I == 4) {
    return std::move(t.__x4);
  }
  else if constexpr (I == 5) {
    return std::move(t.__x5);
  }
  else if constexpr (I == 6) {
    return std::move(t.__x6);
  }
  else if constexpr (I == 7) {
    return std::move(t.__x7);
  }
  else if constexpr (I == 8) {
    return std::move(t.__x8);
  }
  else if constexpr (I == 9) {
    return std::move(t.__x9);
  }
  else {
    static_assert(&t == nullptr);
  }
}

template<class, class...>
inline constexpr auto __count_occurrences = 0;

template<class T, class T0, class... Ts>
inline constexpr auto __count_occurrences<T, T0, Ts...> = static_cast<int>(is_same_v<T, T0>) + __count_occurrences<T, Ts...>;

template<class T, class... Ts>
inline constexpr auto __is_unique = __count_occurrences<T, Ts...> == 1;

template<class T, class... Ts>
requires __is_unique<T, Ts...>
constexpr T& get(tuple<Ts...>& t) noexcept
{
  if constexpr (std::same_as<T, Ts...[0]>) {
    return t.__x0;
  }
  else if constexpr (std::same_as<T, Ts...[1]>) {
    return t.__x1;
  }
  else if constexpr (std::same_as<T, Ts...[2]>) {
    return t.__x2;
  }
  else if constexpr (std::same_as<T, Ts...[3]>) {
    return t.__x3;
  }
  else if constexpr (std::same_as<T, Ts...[4]>) {
    return t.__x4;
  }
  else if constexpr (std::same_as<T, Ts...[5]>) {
    return t.__x5;
  }
  else if constexpr (std::same_as<T, Ts...[6]>) {
    return t.__x6;
  }
  else if constexpr (std::same_as<T, Ts...[7]>) {
    return t.__x7;
  }
  else if constexpr (std::same_as<T, Ts...[8]>) {
    return t.__x8;
  }
  else if constexpr (std::same_as<T, Ts...[9]>) {
    return t.__x9;
  }
}

template<class T, class... Ts>
requires __is_unique<T, Ts...>
constexpr T const& get(tuple<Ts...> const& t) noexcept
{
  if constexpr (std::same_as<T, Ts...[0]>) {
    return t.__x0;
  }
  else if constexpr (std::same_as<T, Ts...[1]>) {
    return t.__x1;
  }
  else if constexpr (std::same_as<T, Ts...[2]>) {
    return t.__x2;
  }
  else if constexpr (std::same_as<T, Ts...[3]>) {
    return t.__x3;
  }
  else if constexpr (std::same_as<T, Ts...[4]>) {
    return t.__x4;
  }
  else if constexpr (std::same_as<T, Ts...[5]>) {
    return t.__x5;
  }
  else if constexpr (std::same_as<T, Ts...[6]>) {
    return t.__x6;
  }
  else if constexpr (std::same_as<T, Ts...[7]>) {
    return t.__x7;
  }
  else if constexpr (std::same_as<T, Ts...[8]>) {
    return t.__x8;
  }
  else if constexpr (std::same_as<T, Ts...[9]>) {
    return t.__x9;
  }
  else {
    static_assert(&t == nullptr, "not implemented");
  }
}

template<class T, class... Ts>
requires __is_unique<T, Ts...>
constexpr T&& get(tuple<Ts...>&& t) noexcept
{
  if constexpr (std::same_as<T, Ts...[0]>) {
    return std::move(t.__x0);
  }
  else if constexpr (std::same_as<T, Ts...[1]>) {
    return std::move(t.__x1);
  }
  else if constexpr (std::same_as<T, Ts...[2]>) {
    return std::move(t.__x2);
  }
  else if constexpr (std::same_as<T, Ts...[3]>) {
    return std::move(t.__x3);
  }
  else if constexpr (std::same_as<T, Ts...[4]>) {
    return std::move(t.__x4);
  }
  else if constexpr (std::same_as<T, Ts...[5]>) {
    return std::move(t.__x5);
  }
  else if constexpr (std::same_as<T, Ts...[6]>) {
    return std::move(t.__x6);
  }
  else if constexpr (std::same_as<T, Ts...[7]>) {
    return std::move(t.__x7);
  }
  else if constexpr (std::same_as<T, Ts...[8]>) {
    return std::move(t.__x8);
  }
  else if constexpr (std::same_as<T, Ts...[9]>) {
    return std::move(t.__x9);
  }
  else {
    static_assert(&t == nullptr, "not implemented");
  }
}

template<class T, class... Ts>
requires __is_unique<T, Ts...>
constexpr T const&& get(tuple<Ts...> const&& t) noexcept
{
  if constexpr (std::same_as<T, Ts...[0]>) {
    return std::move(t.__x0);
  }
  else if constexpr (std::same_as<T, Ts...[1]>) {
    return std::move(t.__x1);
  }
  else if constexpr (std::same_as<T, Ts...[2]>) {
    return std::move(t.__x2);
  }
  else if constexpr (std::same_as<T, Ts...[3]>) {
    return std::move(t.__x3);
  }
  else if constexpr (std::same_as<T, Ts...[4]>) {
    return std::move(t.__x4);
  }
  else if constexpr (std::same_as<T, Ts...[5]>) {
    return std::move(t.__x5);
  }
  else if constexpr (std::same_as<T, Ts...[6]>) {
    return std::move(t.__x6);
  }
  else if constexpr (std::same_as<T, Ts...[7]>) {
    return std::move(t.__x7);
  }
  else if constexpr (std::same_as<T, Ts...[8]>) {
    return std::move(t.__x8);
  }
  else if constexpr (std::same_as<T, Ts...[9]>) {
    return std::move(t.__x9);
  }
  else {
    static_assert(&t == nullptr, "not implemented");
  }
}

template<class F, class Tuple, size_t... N>
constexpr decltype(auto) __apply_impl(F&& f, Tuple&& tuple, std::index_sequence<N...>) noexcept(noexcept(std::invoke(std::forward<F>(f), std::get<N>(std::forward<Tuple>(tuple))...)))
{
  return std::invoke(std::forward<F>(f), std::get<N>(std::forward<Tuple>(tuple))...);
}

template<class F, class Tuple>
constexpr decltype(auto) apply(F&& f, Tuple&& tuple) noexcept(noexcept(__apply_impl(std::forward<F>(f), std::forward<Tuple>(tuple), std::make_index_sequence<tuple_size_v<remove_cvref_t<Tuple>>>())))
{
  return __apply_impl(std::forward<F>(f), std::forward<Tuple>(tuple), std::make_index_sequence<tuple_size_v<remove_cvref_t<Tuple>>>());
}

template<class... Ts>
requires (swappable<Ts> and ...)
constexpr void swap(tuple<Ts...>& x, tuple<Ts...>& y) noexcept(noexcept(x.swap(y)))
{
  x.swap(y);
}

template<class... Ts>
requires (swappable<Ts const> and ...)
constexpr void swap(tuple<Ts...> const& x, tuple<Ts...> const& y) noexcept(noexcept(x.swap(y)))
{
  x.swap(y);
}


template <class... _Tp, class _Alloc>
struct _LIBCPP_TEMPLATE_VIS uses_allocator<tuple<_Tp...>, _Alloc> : true_type {};

template<class... TTypes>
constexpr tuple<unwrap_ref_decay_t<TTypes>...> make_tuple(TTypes&&... t)
{
  return tuple<unwrap_ref_decay_t<TTypes>...>(std::forward<TTypes>(t)...);
}

template<class T, class Tuple, size_t... I>
constexpr T __make_from_tuple_impl(Tuple&& t, index_sequence<I...>) noexcept(noexcept(T(get<I>(std::forward<Tuple>(t))...))) {
  return T(std::get<I>(std::forward<Tuple>(t))...);
}

template<class T, __tuple_like Tuple>
constexpr T make_from_tuple(Tuple&& t) noexcept(noexcept(__make_from_tuple_impl<T>(std::forward<Tuple>(t), make_index_sequence<tuple_size_v<remove_reference_t<Tuple>>>())))
{
  return __make_from_tuple_impl<T>(std::forward<Tuple>(t), make_index_sequence<tuple_size_v<remove_reference_t<Tuple>>>());
}

template<class... TTypes>
constexpr tuple<TTypes&&...> forward_as_tuple(TTypes&&... t) noexcept
{
  return tuple<TTypes&&...>(std::forward<TTypes>(t)...);
}

template<class... Ts>
constexpr tuple<Ts&...> tie(Ts&... t) noexcept
{
  return tuple<Ts&...>(t...);
}

template <class... _TTypes, class... _UTypes, template <class> class _TQual, template <class> class _UQual>
  requires requires { typename tuple<common_reference_t<_TQual<_TTypes>, _UQual<_UTypes>>...>; }
struct basic_common_reference<tuple<_TTypes...>, tuple<_UTypes...>, _TQual, _UQual> {
  using type = tuple<common_reference_t<_TQual<_TTypes>, _UQual<_UTypes>>...>;
};

template <class... _TTypes, class... _UTypes>
  requires requires { typename tuple<common_type_t<_TTypes, _UTypes>...>; }
struct common_type<tuple<_TTypes...>, tuple<_UTypes...>> {
  using type = tuple<common_type_t<_TTypes, _UTypes>...>;
};

struct __ignore {
  __ignore() = default;
  __ignore(__ignore&&) = default;
  __ignore(__ignore const&) = default;
  __ignore& operator=(__ignore&&) = default;
  __ignore& operator=(__ignore const&) = default;

  [[clang::always_inline, gnu::nodebug]] constexpr __ignore(auto&&) noexcept {}
  [[clang::always_inline, gnu::nodebug]] constexpr __ignore& operator=(auto&&) noexcept { return *this; }
  [[clang::always_inline, gnu::nodebug]] constexpr __ignore const& operator=(auto&&) const noexcept { return *this; }
};

constexpr auto ignore = __ignore();

#  if _LIBCPP_STD_VER >= 14

namespace __find_detail {

static constexpr size_t __not_found = static_cast<size_t>(-1);
static constexpr size_t __ambiguous = __not_found - 1;

inline _LIBCPP_HIDE_FROM_ABI constexpr size_t __find_idx_return(size_t __curr_i, size_t __res, bool __matches) {
  return !__matches ? __res : (__res == __not_found ? __curr_i : __ambiguous);
}

template <size_t _Nx>
inline _LIBCPP_HIDE_FROM_ABI constexpr size_t __find_idx(size_t __i, const bool (&__matches)[_Nx]) {
  return __i == _Nx
           ? __not_found
           : __find_detail::__find_idx_return(__i, __find_detail::__find_idx(__i + 1, __matches), __matches[__i]);
}

template <class _T1, class... _Args>
struct __find_exactly_one_checked {
  static constexpr bool __matches[sizeof...(_Args)] = {is_same<_T1, _Args>::value...};
  static constexpr size_t value                     = __find_detail::__find_idx(0, __matches);
  static_assert(value != __not_found, "type not found in type list");
  static_assert(value != __ambiguous, "type occurs more than once in type list");
};

template <class _T1>
struct __find_exactly_one_checked<_T1> {
  static_assert(!is_same<_T1, _T1>::value, "type not in empty type list");
};

} // namespace __find_detail

template <typename _T1, typename... _Args>
struct __find_exactly_one_t : public __find_detail::__find_exactly_one_checked<_T1, _Args...> {};

#  endif

#endif // __experimental_tuple
_LIBCPP_END_NAMESPACE_STD

_LIBCPP_POP_MACROS

// clang-format on

#if !defined(_LIBCPP_REMOVE_TRANSITIVE_INCLUDES) && _LIBCPP_STD_VER <= 20
#  include <exception>
#  include <iosfwd>
#  include <new>
#  include <type_traits>
#  include <typeinfo>
#  include <utility>
#endif

#endif // _LIBCPP_TUPLE
